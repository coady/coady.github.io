<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GraphQL - ORM | Pythonicity</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://coady.github.io/posts/graphql-orm/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="A. Coady">
<link rel="prev" href="../closing-files/" title="Closing files" type="text/html">
<meta property="og:site_name" content="Pythonicity">
<meta property="og:title" content="GraphQL - ORM">
<meta property="og:url" content="https://coady.github.io/posts/graphql-orm/">
<meta property="og:description" content="GraphQL is the new ORM.¶REST and ORMs are both infamous for:

over-fetching: fetching more data than is needed per request
under-fetching: fetching less data than is needed, requiring multiple request">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-07-06T00:00:00-07:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../">

            <span id="blog-title">Pythonicity</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.ipynb" id="sourcelink" class="nav-link">Source</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>
                </li>
<li class="nav-item">
<a href="https://github.com/coady/coady.github.io" class="nav-link">Source</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">GraphQL - ORM</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    A. Coady
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-07-06T00:00:00-07:00" itemprop="datePublished" title="2020-07-06">2020-07-06</time></a>
            </p>
            
        <p class="sourceline"><a href="index.ipynb" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="GraphQL-is-the-new-ORM.">GraphQL is the new ORM.<a class="anchor-link" href="#GraphQL-is-the-new-ORM.">¶</a>
</h2>
<p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> and <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORMs</a> are both infamous for:</p>
<ul>
<li>over-fetching: fetching more data than is needed per request</li>
<li>under-fetching: fetching less data than is needed, requiring multiple requests</li>
<li>select N+1 problem: under-fetching applied to multiple associated objects</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/GraphQL">GraphQL</a> aims to overcome REST's shortcomings through a flexible query language, and succeeds in doing so on the client side.  But on the server side, GraphQL resolvers have effectively recreated the same over- and under- fetching problems that have long plagued ORMs.  The fact that ORMs remain popular despite of their inefficiency is a testament to the benefits of having in-memory objects behave consistently.  There is no such trade-off for server-side GraphQL, where the only point of the objects is to be immediately serialized.</p>
<p>The so-called <a href="https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching">N+1 problem</a> is generally acknowledged in the GraphQL community, but this article will argue only the symptoms are being addressed with workarounds like <a href="https://github.com/graphql/dataloader">dataloader</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example">Example<a class="anchor-link" href="#Example">¶</a>
</h3>
<p>The problems can be seen immediately in GraphQL's own introductory <a href="https://graphql.org/learn/execution/#root-fields-resolvers">resolver example</a>.</p>
<div class="highlight"><pre><span></span><span class="nx">Query</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">human</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">context</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">loadHumanByID</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">id</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
      <span class="nx">userData</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nx">Human</span><span class="p">(</span><span class="nx">userData</span><span class="p">)</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Human</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">name</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>What makes the <code>name</code> resolver trivial?  It's pre-fetched by <code>loadHumanByID</code>, whose only parameter is <code>id</code>, so it's clearly unaware of whether <code>name</code> has been requested.  What if the requested field was a nested object, or a json field, or just a large text blob?  Then one would clearly be directed towards using a non-trivial resolver which fetches the field on demand.  Of course, but then whatever work is common in the human <code>id</code> lookup is duplicated.</p>
<p>This is by no means specific to SQL or relational databases, but SQL is a convenient lingua franca of databases to demonstrate the inefficiency.  The choices are:</p>
<ul>
<li><code>SELECT * FROM human WHERE id = ?</code></li>
<li>
<code>SELECT field FROM human WHERE id = ?</code> repeated for each "expensive" field</li>
</ul>
<p>Even in the simplest possible example, over-fetching has already occurred, and the only proposed workaround is under-fetching.  The single query we want is:</p>
<ul>
<li>
<code>SELECT f1, f2, ... FROM human WHERE id = ?</code> for requested fields</li>
</ul>
<p>In other words, exactly what happens with ORMs, except even ORMs typically offer an option of requesting a subset of fields.  Naturally the problem gets worse with list fields.</p>
<div class="highlight"><pre><span></span><span class="nx">Human</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">appearsIn</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">appearsIn</span> <span class="c1">// returns [ 4, 5, 6 ]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Human</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">starships</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">starshipIDs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
      <span class="nx">id</span> <span class="p">=&gt;</span> <span class="nx">context</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">loadStarshipByID</span><span class="p">(</span><span class="nx">id</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span>
        <span class="nx">shipData</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nx">Starship</span><span class="p">(</span><span class="nx">shipData</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now there are two sets of associate keys (<code>.appearsIn</code> and <code>.starshipIDs</code>) that have been over-fetched.  Nonetheless <code>starships</code> is  under-fetched as well.  The <code>starships</code> resolver is neither the most efficient nor the simplest way of resolving this field:</p>
<ul>
<li>fetch all the data by human <code>id</code> in the <code>starships</code> resolver</li>
<li>fetch all the data in bulk by <code>starshipIDs</code>
</li>
<li>push the resolution down to the <code>Starship</code> layer if forced to fetch one at a time</li>
</ul>
<p>The example implementation seems to be going out of its way to showcase JavaScript promises.  And the assumptions being made about the underlying data store are unusual:</p>
<ol>
<li>The data is relational in nature.</li>
<li>Associative keys have neglible cost to pre-fetch.</li>
<li>But joins are not available.</li>
<li>And neither are <code>primary key in</code> queries.</li>
</ol>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Workaround">Workaround<a class="anchor-link" href="#Workaround">¶</a>
</h3>
<p>From GraphQL's <a href="https://graphql.org/learn/best-practices/#server-side-batching-caching">best practices</a></p>
<blockquote>
<p>GraphQL is designed in a way that allows you to write clean code on the server, where every field on every type has a focused single-purpose function for resolving that value. However without additional consideration, a naive GraphQL service could be very "chatty" or repeatedly load data from your databases.</p>
<p>This is commonly solved by a batching technique, where multiple requests for data from a backend are collected over a short period of time and then dispatched in a single request to an underlying database or microservice by using a tool like Facebook's DataLoader.</p>
</blockquote>
<p>That's an understatement.  It's not clear how "naive" differs from best practice.</p>
<p>Clearly there is value in transforming multiple <code>primary key =</code> queries into a single <code>primary key in</code> query.  As in the <code>starships</code> example however, that can be done more simply in the parent resolver.  There is more value in not needing a <code>primary key in</code> query at all.  Furthermore adding caching to a dataloader avoids the central issue.</p>
<p>Again reminiscent of ORMs, any data layer can add caching.  The point is efficiently resolving a query requires context, which strict adherence to single-purpose resolvers explictly disregards.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Aggregation">Aggregation<a class="anchor-link" href="#Aggregation">¶</a>
</h3>
<p>The inefficencies becomes even more glaring when moving beyond associative keys.  Nearly any aggregation requires knowing what summaries are requested.  Such as if the <code>appearsIn</code> field optionally included counts or times.  Using SQL as an example again, the query would resemble one of:</p>
<ul>
<li><code>SELECT distinct field FROM ...</code></li>
<li><code>SELECT field, count(*) FROM ... GROUP BY field</code></li>
</ul>
<p>The conditional logic <code>if "count" in requested_fields</code> must exist in some form in the code, because the alternatives are over-fetching or under-fetching.  Both of which are far more inefficient in this scenario than in the "select N+1" problem.  A dataloader-esque approach is not going to be applicable to "group by" operations.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Computation">Computation<a class="anchor-link" href="#Computation">¶</a>
</h3>
<p>One last generalized example: computed fields.  What are typically query flags in REST (and <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>) APIs, become field selections in GraphQL.</p>
<p>For example, computing scores in a search engine interface.  Instead of a <code>scores: Boolean! = false</code> input option, the more obvious approach would be to skip score calculation when the <code>score</code> field isn't requested.</p>
<p>As with aggregation, the same pattern recurs.  It's unacceptable to over-fetch, i.e., compute the scores when not needed.  It's worse still to under-fetch, i.e., run some sort of lean search that will find matches and then go back and compute scores later.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Solution">Solution<a class="anchor-link" href="#Solution">¶</a>
</h3>
<p>The inescapable conclusion is that in some cases parent resolvers need to know which of their children are being requested.  There's no need to throw away GraphQL's server-side resolver hierarchy.  No one is advocating a thousand line root resolver named <code>RunIt</code> that processes the entire query.</p>
<p>All that's needed is a conceptual shift which encourages introspecting the <code>GraphQLResolveInfo</code> object.  The requested fields are right there waiting to be useful, but good luck finding documentation and examples to that effect.  In every non-trivial GraphQL project, this author has used a utility like:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">selections</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">"""Return tree of field name selections."""</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">selection_set</span><span class="p">,</span> <span class="s1">'selections'</span><span class="p">,</span> <span class="p">[])</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">selections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Those fields would be checked or passed to a data layer as needed.  For example, in <a href="https://www.djangoproject.com">Django's</a> ORM, it could be as simple as appending a query set with <code>.values(*selections(*info.nodes))</code>.</p>
<p>Well, almost.  The next issue is that typical GraphQL model validators raise an error if required fields are missing.  Thanks validator; the field is missing because the client didn't request it.</p>
<p>This is actually a different age-old problem: equivocating "optional" and "nullable".  GraphQL requires populating all requested fields, and specifiying whether they may be null.  Server-side implementations understandably, but still incorrectly, interpret that by making nullables optional and non-nullables required at the model layer.  So typically it's necessary to pad resolved objects with empty (but not null) data.</p>
<p>Although a minor problem, it reveals the bias related to single-purpose resolvers.  The point of GraphQL is to efficiently return only the requested fields, yet standard practice in GraphQL models is to require populating fields that haven't been requested.</p>
<p>Over- and under- fetching can be addressed directly in resolvers, with the data layer's own interface, instead of hidden behind another abstraction layer.</p>

</div>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../closing-files/" rel="prev" title="Closing files">Previous post</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></article><!--End of body content--><footer id="footer">
            Contents © 2020         <a href="mailto:aric.coady@gmail.com">A. Coady</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
