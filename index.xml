<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Pythonicity</title>
<link>https://coady.github.io/index.html</link>
<atom:link href="https://coady.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>pythonicity | pīˈTHänisədē | noun the quality of being Pythonic</description>
<generator>quarto-1.2.313</generator>
<lastBuildDate>Mon, 02 Jan 2023 00:00:00 GMT</lastBuildDate>
<item>
  <title>Random Selection</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/random-selection.html</link>
  <description><![CDATA[ 




<p>Random selection utilities used to be common in interviews. Less so in Python circles because of the builtin <code>random</code> module. Still advanced examples may come up. First is a generalization of <code>shuffle</code> and <code>sample</code>.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb1-2"><span class="im" style="color: #00769E;">import</span> random</span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="kw" style="color: #003B4F;">def</span> shuffled(iterable):</span>
<span id="cb1-5">    <span class="co" style="color: #5E5E5E;">"""Generate values in random order for any iterable.</span></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;">    </span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;">    Faster than `random.shuffle` if not all values are required.</span></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;">    More flexible than `random.sample` if the desired number is unknown a priori.</span></span>
<span id="cb1-9"><span class="co" style="color: #5E5E5E;">    """</span></span>
<span id="cb1-10">    values <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(iterable)</span>
<span id="cb1-11">    <span class="cf" style="color: #003B4F;">while</span> values:</span>
<span id="cb1-12">        index <span class="op" style="color: #5E5E5E;">=</span> random.randrange(<span class="dv" style="color: #AD0000;">0</span>, <span class="bu" style="color: null;">len</span>(values))</span>
<span id="cb1-13">        values[index], values[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>] <span class="op" style="color: #5E5E5E;">=</span> values[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>], values[index]</span>
<span id="cb1-14">        <span class="cf" style="color: #003B4F;">yield</span> values.pop()</span>
<span id="cb1-15"></span>
<span id="cb1-16"><span class="bu" style="color: null;">list</span>(itertools.islice(shuffled(<span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">10</span>)), <span class="dv" style="color: #AD0000;">5</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>[9, 7, 5, 4, 6]</code></pre>
</div>
</div>
<p>Next up is a random sample in a single pass, e.g., if the data is being read from a large file. The solution requires <a href="https://en.wikipedia.org/wiki/Mathematical_induction">mathematical induction</a>:</p>
<ul>
<li>each Nth element has a fair chance of being selected</li>
<li>each previously selected element has a fair chance of being removed</li>
</ul>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;">def</span> sample(iterable, k):</span>
<span id="cb3-2">    <span class="co" style="color: #5E5E5E;">"""Return a random sample from any iterable in a single pass.</span></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;">    </span></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;">    More memory efficient than `random.sample`.</span></span>
<span id="cb3-5"><span class="co" style="color: #5E5E5E;">    """</span></span>
<span id="cb3-6">    it <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">iter</span>(iterable)</span>
<span id="cb3-7">    selection <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(itertools.islice(it, k))</span>
<span id="cb3-8">    <span class="co" style="color: #5E5E5E;"># error handling and shuffling are consistent with random.sample</span></span>
<span id="cb3-9">    <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> <span class="dv" style="color: #AD0000;">0</span> <span class="op" style="color: #5E5E5E;">&lt;=</span> k <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="bu" style="color: null;">len</span>(selection):</span>
<span id="cb3-10">        <span class="cf" style="color: #003B4F;">raise</span> <span class="pp" style="color: #AD0000;">ValueError</span>(<span class="st" style="color: #20794D;">"sample larger than population"</span>)</span>
<span id="cb3-11">    random.shuffle(selection)</span>
<span id="cb3-12">    <span class="cf" style="color: #003B4F;">for</span> count, value <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">enumerate</span>(it, k <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb3-13">        index <span class="op" style="color: #5E5E5E;">=</span> random.randrange(<span class="dv" style="color: #AD0000;">0</span>, count)</span>
<span id="cb3-14">        <span class="cf" style="color: #003B4F;">if</span> index <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="bu" style="color: null;">len</span>(selection):</span>
<span id="cb3-15">            selection[index] <span class="op" style="color: #5E5E5E;">=</span> value</span>
<span id="cb3-16">    <span class="cf" style="color: #003B4F;">return</span> selection</span>
<span id="cb3-17"></span>
<span id="cb3-18">sample(<span class="bu" style="color: null;">iter</span>(<span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">10</span>)), <span class="dv" style="color: #AD0000;">5</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[1, 2, 6, 3, 8]</code></pre>
</div>
</div>



 ]]></description>
  <category>interviews</category>
  <guid>https://coady.github.io/posts/random-selection.html</guid>
  <pubDate>Mon, 02 Jan 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Primes</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/primes.html</link>
  <description><![CDATA[ 




<p>An old interview challenge is to generate prime numbers or check if a number is prime. No advanced mathematics needed, just variants on the <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>. Starting with a basic prime checker.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;">def</span> isprime(n):</span>
<span id="cb1-2">    divs <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">2</span>, <span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>) <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>)</span>
<span id="cb1-3">    <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> d <span class="cf" style="color: #003B4F;">for</span> d <span class="kw" style="color: #003B4F;">in</span> divs)</span>
<span id="cb1-4"></span>
<span id="cb1-5"><span class="op" style="color: #5E5E5E;">%</span>time isprime(<span class="dv" style="color: #AD0000;">1_000_003</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 83 µs, sys: 1e+03 ns, total: 84 µs
Wall time: 85.1 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>True</code></pre>
</div>
</div>
<p>A common optimization is to skip even numbers.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;">def</span> isprime(n):</span>
<span id="cb4-2">    divs <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">3</span>, <span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>) <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb4-3">    <span class="cf" style="color: #003B4F;">return</span> n <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">2</span> <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> d <span class="cf" style="color: #003B4F;">for</span> d <span class="kw" style="color: #003B4F;">in</span> divs)</span>
<span id="cb4-4"></span>
<span id="cb4-5"><span class="op" style="color: #5E5E5E;">%</span>time isprime(<span class="dv" style="color: #AD0000;">1_000_003</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 43 µs, sys: 0 ns, total: 43 µs
Wall time: 46.3 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>True</code></pre>
</div>
</div>
<p>Brief digression on that optimization. There’s nothing special about removing multiples of 2; removing multiples is the whole point. The <code>step</code> scalar could instead be thought of as a cycle: <code>itertools.accumulate(itertools.repeat(2))</code>. So removing multiples of 3 would remove every third step: <code>itertools.accumulate(itertools.cycle([2, 4]))</code>.</p>
<p>Or the equivalent could be done with slicing.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb7-2"></span>
<span id="cb7-3"><span class="kw" style="color: #003B4F;">def</span> isprime(n):</span>
<span id="cb7-4">    divs <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">5</span>, <span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>) <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb7-5">    <span class="cf" style="color: #003B4F;">return</span> n <span class="kw" style="color: #003B4F;">in</span> (<span class="dv" style="color: #AD0000;">2</span>, <span class="dv" style="color: #AD0000;">3</span>) <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> d <span class="cf" style="color: #003B4F;">for</span> d <span class="kw" style="color: #003B4F;">in</span> itertools.chain(divs[::<span class="dv" style="color: #AD0000;">3</span>], divs[<span class="dv" style="color: #AD0000;">1</span>::<span class="dv" style="color: #AD0000;">3</span>]))</span>
<span id="cb7-6"></span>
<span id="cb7-7"><span class="op" style="color: #5E5E5E;">%</span>time isprime(<span class="dv" style="color: #AD0000;">1_000_003</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 42 µs, sys: 1 µs, total: 43 µs
Wall time: 44.1 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>True</code></pre>
</div>
</div>
<p>The catch is the cycles grow exponentially with diminishing returns on each successive number.</p>
<p>Onto prime generation, while keeping the odds-only optimization. Typically it’s requested to generate the first <code>N</code> primes, or up to some value. But that’s easily generalized with <code>itertools.islice</code> and <code>itertools.takewhile</code>. A more Pythonic approach is an unbounded generator.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="kw" style="color: #003B4F;">def</span> primes():</span>
<span id="cb10-2">    <span class="cf" style="color: #003B4F;">yield</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb10-3">    ints <span class="op" style="color: #5E5E5E;">=</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb10-4">    <span class="cf" style="color: #003B4F;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb10-5">        prime <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">next</span>(ints)</span>
<span id="cb10-6">        <span class="cf" style="color: #003B4F;">yield</span> prime</span>
<span id="cb10-7">        ints <span class="op" style="color: #5E5E5E;">=</span> (n <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> ints <span class="cf" style="color: #003B4F;">if</span> n <span class="op" style="color: #5E5E5E;">%</span> prime)</span>
<span id="cb10-8"></span>
<span id="cb10-9"><span class="bu" style="color: null;">list</span>(itertools.islice(primes(), <span class="dv" style="color: #AD0000;">10</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>[2, 3, 5, 7, 9, 11, 13, 15, 17, 19]</code></pre>
</div>
</div>
<p>Elegant, but doesn’t work. The problem is the scoping of <code>prime</code>, which is being used in the generator expression but also modified in the loop. Instead it can be replaced with a <code>filter</code> on a partially bound function, but unfortunately <code>functools.partial</code> only binds left arguments and <code>rmod</code> is needed here. One alternative is to use bound methods as a first-class function, even dunder methods.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="kw" style="color: #003B4F;">def</span> primes():</span>
<span id="cb12-2">    <span class="cf" style="color: #003B4F;">yield</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb12-3">    ints <span class="op" style="color: #5E5E5E;">=</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb12-4">    <span class="cf" style="color: #003B4F;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb12-5">        prime <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">next</span>(ints)</span>
<span id="cb12-6">        <span class="cf" style="color: #003B4F;">yield</span> prime</span>
<span id="cb12-7">        ints <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">filter</span>(prime.<span class="fu" style="color: #4758AB;">__rmod__</span>, ints)</span>
<span id="cb12-8"></span>
<span id="cb12-9"><span class="op" style="color: #5E5E5E;">%</span>time <span class="bu" style="color: null;">next</span>(itertools.islice(primes(), <span class="dv" style="color: #AD0000;">1000</span>, <span class="va" style="color: #111111;">None</span>))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 30.7 ms, sys: 1.82 ms, total: 32.5 ms
Wall time: 32 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>7927</code></pre>
</div>
</div>
<p>Elegant, but slow and could overflow the stack. A more traditional approach would use the same checking logic as <code>isprime</code>, but also cache the primes so as to not duplicate divisors.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><span class="kw" style="color: #003B4F;">def</span> primes():</span>
<span id="cb15-2">    <span class="cf" style="color: #003B4F;">yield</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb15-3">    primes <span class="op" style="color: #5E5E5E;">=</span> []</span>
<span id="cb15-4">    <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb15-5">        <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> p <span class="cf" style="color: #003B4F;">for</span> p <span class="kw" style="color: #003B4F;">in</span> itertools.takewhile(<span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>).<span class="fu" style="color: #4758AB;">__ge__</span>, primes)):</span>
<span id="cb15-6">            primes.append(n)</span>
<span id="cb15-7">            <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb15-8"></span>
<span id="cb15-9"><span class="op" style="color: #5E5E5E;">%</span>time <span class="bu" style="color: null;">next</span>(itertools.islice(primes(), <span class="dv" style="color: #AD0000;">1000</span>, <span class="va" style="color: #111111;">None</span>))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 5.49 ms, sys: 423 µs, total: 5.92 ms
Wall time: 5.8 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>7927</code></pre>
</div>
</div>
<p>Onto interface design. The primes are being stored anyway, so it would be nice if they were re-iterable. A generator can be written as a class with <code>__iter__</code> and <code>__next__</code>, but an under-appreciated feature is that <code>__iter__</code> itself can be a generator. And now that it’s a class, <code>isprime</code> can be expressed as <code>in</code> while also benefiting from the cache.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="kw" style="color: #003B4F;">class</span> Primes:</span>
<span id="cb18-2">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>):</span>
<span id="cb18-3">        <span class="va" style="color: #111111;">self</span>.ints <span class="op" style="color: #5E5E5E;">=</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb18-4">        <span class="va" style="color: #111111;">self</span>.cache <span class="op" style="color: #5E5E5E;">=</span> [<span class="dv" style="color: #AD0000;">2</span>]</span>
<span id="cb18-5">    </span>
<span id="cb18-6">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__iter__</span>(<span class="va" style="color: #111111;">self</span>):</span>
<span id="cb18-7">        <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.cache</span>
<span id="cb18-8">        <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> <span class="va" style="color: #111111;">self</span>.ints:</span>
<span id="cb18-9">            <span class="cf" style="color: #003B4F;">if</span> n <span class="kw" style="color: #003B4F;">in</span> <span class="va" style="color: #111111;">self</span>:</span>
<span id="cb18-10">                <span class="va" style="color: #111111;">self</span>.cache.append(n)</span>
<span id="cb18-11">                <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb18-12"></span>
<span id="cb18-13">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__contains__</span>(<span class="va" style="color: #111111;">self</span>, n):</span>
<span id="cb18-14">        <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> p <span class="cf" style="color: #003B4F;">for</span> p <span class="kw" style="color: #003B4F;">in</span> itertools.takewhile(<span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>).<span class="fu" style="color: #4758AB;">__ge__</span>, <span class="va" style="color: #111111;">self</span>))</span>
<span id="cb18-15"></span>
<span id="cb18-16">primes <span class="op" style="color: #5E5E5E;">=</span> Primes()</span>
<span id="cb18-17"><span class="op" style="color: #5E5E5E;">%</span>time <span class="bu" style="color: null;">next</span>(itertools.islice(primes, <span class="dv" style="color: #AD0000;">1000</span>, <span class="va" style="color: #111111;">None</span>))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 7.89 ms, sys: 483 µs, total: 8.37 ms
Wall time: 8 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>7927</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb21" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><span class="op" style="color: #5E5E5E;">%</span>time <span class="dv" style="color: #AD0000;">1_000_003</span> <span class="kw" style="color: #003B4F;">in</span> primes</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 34 µs, sys: 0 ns, total: 34 µs
Wall time: 37 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>True</code></pre>
</div>
</div>
<p>There’s a hybrid approach though, that’s faster and nearly as simple as the above sieves. Instead of doing repeated divisions, keep track of each found prime along with the next multiple that it would eliminate. The inner loop is then optimized because it only needs to account for collisions.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb24" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><span class="kw" style="color: #003B4F;">def</span> primes():</span>
<span id="cb24-2">    multiples <span class="op" style="color: #5E5E5E;">=</span> {}</span>
<span id="cb24-3">    <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> itertools.count(<span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb24-4">        prime <span class="op" style="color: #5E5E5E;">=</span> multiples.pop(n, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb24-5">        <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> prime:</span>
<span id="cb24-6">            prime <span class="op" style="color: #5E5E5E;">=</span> n</span>
<span id="cb24-7">            <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb24-8">        key <span class="op" style="color: #5E5E5E;">=</span> n <span class="op" style="color: #5E5E5E;">+</span> prime</span>
<span id="cb24-9">        <span class="cf" style="color: #003B4F;">while</span> key <span class="kw" style="color: #003B4F;">in</span> multiples:</span>
<span id="cb24-10">            key <span class="op" style="color: #5E5E5E;">+=</span> prime</span>
<span id="cb24-11">        multiples[key] <span class="op" style="color: #5E5E5E;">=</span> prime</span>
<span id="cb24-12"></span>
<span id="cb24-13"><span class="op" style="color: #5E5E5E;">%</span>time <span class="bu" style="color: null;">next</span>(itertools.islice(primes(), <span class="dv" style="color: #AD0000;">1000</span>, <span class="va" style="color: #111111;">None</span>))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 2.59 ms, sys: 103 µs, total: 2.69 ms
Wall time: 2.7 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>7927</code></pre>
</div>
</div>
<p>Now to add back the odds-only optimization, the step scalar needs to be double the prime number. Another way to reduce collisions is to recognize that each new prime is irrelevant until its square value is reached.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb27" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><span class="kw" style="color: #003B4F;">def</span> primes():</span>
<span id="cb27-2">    <span class="cf" style="color: #003B4F;">yield</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb27-3">    multiples <span class="op" style="color: #5E5E5E;">=</span> {}</span>
<span id="cb27-4">    <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb27-5">        step <span class="op" style="color: #5E5E5E;">=</span> multiples.pop(n, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb27-6">        <span class="cf" style="color: #003B4F;">if</span> step:  <span class="co" style="color: #5E5E5E;"># composite</span></span>
<span id="cb27-7">            key <span class="op" style="color: #5E5E5E;">=</span> n <span class="op" style="color: #5E5E5E;">+</span> step</span>
<span id="cb27-8">            <span class="cf" style="color: #003B4F;">while</span> key <span class="kw" style="color: #003B4F;">in</span> multiples:</span>
<span id="cb27-9">                key <span class="op" style="color: #5E5E5E;">+=</span> step</span>
<span id="cb27-10">            multiples[key] <span class="op" style="color: #5E5E5E;">=</span> step</span>
<span id="cb27-11">        <span class="cf" style="color: #003B4F;">else</span>:  <span class="co" style="color: #5E5E5E;"># prime</span></span>
<span id="cb27-12">            multiples[n <span class="op" style="color: #5E5E5E;">**</span> <span class="dv" style="color: #AD0000;">2</span>] <span class="op" style="color: #5E5E5E;">=</span> n <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb27-13">            <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb27-14"></span>
<span id="cb27-15"><span class="op" style="color: #5E5E5E;">%</span>time <span class="bu" style="color: null;">next</span>(itertools.islice(primes(), <span class="dv" style="color: #AD0000;">1000</span>, <span class="va" style="color: #111111;">None</span>))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 1.37 ms, sys: 5 µs, total: 1.38 ms
Wall time: 1.38 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>7927</code></pre>
</div>
</div>
<p>And finally let’s add back the caching. Yielding a clean interface, an efficient implementation for all use cases, and still relatively simple.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb30" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><span class="kw" style="color: #003B4F;">class</span> Primes:</span>
<span id="cb30-2">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>):</span>
<span id="cb30-3">        <span class="va" style="color: #111111;">self</span>.ints <span class="op" style="color: #5E5E5E;">=</span> itertools.count(<span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">2</span>)</span>
<span id="cb30-4">        <span class="va" style="color: #111111;">self</span>.cache <span class="op" style="color: #5E5E5E;">=</span> [<span class="dv" style="color: #AD0000;">2</span>]</span>
<span id="cb30-5">        <span class="va" style="color: #111111;">self</span>.multiples <span class="op" style="color: #5E5E5E;">=</span> {}</span>
<span id="cb30-6">    </span>
<span id="cb30-7">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__iter__</span>(<span class="va" style="color: #111111;">self</span>):</span>
<span id="cb30-8">        <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.cache</span>
<span id="cb30-9">        <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> <span class="va" style="color: #111111;">self</span>.ints:</span>
<span id="cb30-10">            step <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">self</span>.multiples.pop(n, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb30-11">            <span class="cf" style="color: #003B4F;">if</span> step:  <span class="co" style="color: #5E5E5E;"># composite</span></span>
<span id="cb30-12">                key <span class="op" style="color: #5E5E5E;">=</span> n <span class="op" style="color: #5E5E5E;">+</span> step</span>
<span id="cb30-13">                <span class="cf" style="color: #003B4F;">while</span> key <span class="kw" style="color: #003B4F;">in</span> <span class="va" style="color: #111111;">self</span>.multiples:</span>
<span id="cb30-14">                    key <span class="op" style="color: #5E5E5E;">+=</span> step</span>
<span id="cb30-15">                <span class="va" style="color: #111111;">self</span>.multiples[key] <span class="op" style="color: #5E5E5E;">=</span> step</span>
<span id="cb30-16">            <span class="cf" style="color: #003B4F;">else</span>:  <span class="co" style="color: #5E5E5E;"># prime</span></span>
<span id="cb30-17">                <span class="va" style="color: #111111;">self</span>.multiples[n <span class="op" style="color: #5E5E5E;">**</span> <span class="dv" style="color: #AD0000;">2</span>] <span class="op" style="color: #5E5E5E;">=</span> n <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb30-18">                <span class="va" style="color: #111111;">self</span>.cache.append(n)</span>
<span id="cb30-19">                <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb30-20"></span>
<span id="cb30-21">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__contains__</span>(<span class="va" style="color: #111111;">self</span>, n):</span>
<span id="cb30-22">        <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">all</span>(n <span class="op" style="color: #5E5E5E;">%</span> p <span class="cf" style="color: #003B4F;">for</span> p <span class="kw" style="color: #003B4F;">in</span> itertools.takewhile(<span class="bu" style="color: null;">int</span>(n <span class="op" style="color: #5E5E5E;">**</span> <span class="fl" style="color: #AD0000;">0.5</span>).<span class="fu" style="color: #4758AB;">__ge__</span>, <span class="va" style="color: #111111;">self</span>))</span>
<span id="cb30-23"></span>
<span id="cb30-24">primes <span class="op" style="color: #5E5E5E;">=</span> Primes()</span>
<span id="cb30-25"><span class="op" style="color: #5E5E5E;">%</span>time <span class="dv" style="color: #AD0000;">1_000_003</span> <span class="kw" style="color: #003B4F;">in</span> primes</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 242 µs, sys: 0 ns, total: 242 µs
Wall time: 245 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>True</code></pre>
</div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb33" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><span class="op" style="color: #5E5E5E;">%</span>time <span class="dv" style="color: #AD0000;">1_000_003</span> <span class="kw" style="color: #003B4F;">in</span> primes</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 40 µs, sys: 0 ns, total: 40 µs
Wall time: 43.2 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>True</code></pre>
</div>
</div>



 ]]></description>
  <category>interviews</category>
  <guid>https://coady.github.io/posts/primes.html</guid>
  <pubDate>Sat, 10 Jul 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Hardest Logic Puzzle Ever</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/hardest-logic-puzzle-ever.html</link>
  <description><![CDATA[ 




<section id="how-to-solve-the-hardest-logic-puzzle-ever-programmatically." class="level1">
<h1>How to solve the <a href="https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever">Hardest Logic Puzzle Ever</a> programmatically.</h1>
<blockquote class="blockquote">
<p>Three gods A, B, and C are called, in no particular order, True, False, and Random. True always speaks truly, False always speaks falsely, but whether Random speaks truly or falsely is a completely random matter. Your task is to determine the identities of A, B, and C by asking three yes-no questions; each question must be put to exactly one god. The gods understand English, but will answer all questions in their own language, in which the words for yes and no are <code>da</code> and <code>ja</code>, in some order. You do not know which word means which.</p>
</blockquote>
<p>With 3 binary questions, it’s possible to distinguish <img src="https://latex.codecogs.com/png.latex?2%5E3%20=%208"> scenarios. And there are <img src="https://latex.codecogs.com/png.latex?3!%20=%206"> possibilities. Note that means it’s impossible to additionally identify what <code>da</code> and <code>ja</code> mean, as that would be <img src="https://latex.codecogs.com/png.latex?3!%20*%202%20=%2012"> possibilities.</p>
<p>As always, start with modeling the data. We need a ternary enumeration for the god identifiers. It’s almost a boolean anyway, so let’s use <code>None</code> to indicate neither, i.e., Random. To represent the identities, a mapping from names to ids would be natural. But the mapping has to be one-to-one and onto, and using an immutable key is convenient, so an implicitly ordered tuple of names is also a valid choice. Here a named tuple represents the “state” of the world .</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb1-2"><span class="im" style="color: #00769E;">from</span> typing <span class="im" style="color: #00769E;">import</span> NamedTuple</span>
<span id="cb1-3"></span>
<span id="cb1-4">IDS <span class="op" style="color: #5E5E5E;">=</span> (<span class="va" style="color: #111111;">False</span>, <span class="va" style="color: #111111;">True</span>, <span class="va" style="color: #111111;">None</span>)</span>
<span id="cb1-5">NAMES <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'ABC'</span></span>
<span id="cb1-6">WORDS <span class="op" style="color: #5E5E5E;">=</span> (<span class="st" style="color: #20794D;">'da'</span>, <span class="st" style="color: #20794D;">'ja'</span>)</span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="kw" style="color: #003B4F;">class</span> State(NamedTuple):</span>
<span id="cb1-9">    names: <span class="bu" style="color: null;">str</span>  <span class="co" style="color: #5E5E5E;"># order corresponds to IDS</span></span>
<span id="cb1-10">    yes: <span class="bu" style="color: null;">str</span></span>
<span id="cb1-11"></span>
<span id="cb1-12">STATES <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(itertools.starmap(State, itertools.product(<span class="bu" style="color: null;">map</span>(<span class="st" style="color: #20794D;">''</span>.join, itertools.permutations(NAMES)), WORDS)))</span>
<span id="cb1-13">STATES</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>[State(names='ABC', yes='da'),
 State(names='ABC', yes='ja'),
 State(names='ACB', yes='da'),
 State(names='ACB', yes='ja'),
 State(names='BAC', yes='da'),
 State(names='BAC', yes='ja'),
 State(names='BCA', yes='da'),
 State(names='BCA', yes='ja'),
 State(names='CAB', yes='da'),
 State(names='CAB', yes='ja'),
 State(names='CBA', yes='da'),
 State(names='CBA', yes='ja')]</code></pre>
</div>
</div>
<p>Now to model asking a question. A typical approach would take input parameters relevant to the question, such as asking a god which one they are. And the current reality would be need to be encapsulated to answer the question.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;">def</span> ask(<span class="va" style="color: #111111;">self</span>: State, name: <span class="bu" style="color: null;">str</span>, <span class="bu" style="color: null;">id</span>) <span class="op" style="color: #5E5E5E;">-&gt;</span> <span class="bu" style="color: null;">str</span>:</span>
<span id="cb3-2">    <span class="co" style="color: #5E5E5E;">"""Ask `name`: are you `id`?"""</span></span></code></pre></div>
</div>
<p>The problem with that approach is Random’s answer would have to be modeled as actually random, which would require running many simulations. Since this is a logic puzzle, it’s easier to model Random’s answer as non-deterministic, i.e., could answer either way. The question will take as input the current set of possible states, splitting the states into two groups corresponding to answers da or ja. This function will be used in a search algorithm anyway, so it’s effectively participating in the search.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;">def</span> ask(name: <span class="bu" style="color: null;">str</span>, <span class="bu" style="color: null;">id</span>, states: <span class="bu" style="color: null;">set</span>) <span class="op" style="color: #5E5E5E;">-&gt;</span> <span class="bu" style="color: null;">dict</span>:</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;">"""Ask `name`: are you `id`? and return mapping of answers to possible states."""</span></span>
<span id="cb4-3">    groups <span class="op" style="color: #5E5E5E;">=</span> {word: <span class="bu" style="color: null;">set</span>() <span class="cf" style="color: #003B4F;">for</span> word <span class="kw" style="color: #003B4F;">in</span> WORDS}</span>
<span id="cb4-4">    <span class="cf" style="color: #003B4F;">for</span> state <span class="kw" style="color: #003B4F;">in</span> states:</span>
<span id="cb4-5">        identity <span class="op" style="color: #5E5E5E;">=</span> IDS[state.names.index(name)]</span>
<span id="cb4-6">        truth <span class="op" style="color: #5E5E5E;">=</span> identity <span class="op" style="color: #5E5E5E;">==</span> <span class="bu" style="color: null;">id</span></span>
<span id="cb4-7">        words <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">sorted</span>(WORDS, key<span class="op" style="color: #5E5E5E;">=</span>state.yes.<span class="fu" style="color: #4758AB;">__eq__</span>)</span>
<span id="cb4-8">        <span class="cf" style="color: #003B4F;">if</span> identity <span class="kw" style="color: #003B4F;">in</span> (<span class="va" style="color: #111111;">True</span>, <span class="va" style="color: #111111;">None</span>):</span>
<span id="cb4-9">            groups[words[truth]].add(state)</span>
<span id="cb4-10">        <span class="cf" style="color: #003B4F;">if</span> identity <span class="kw" style="color: #003B4F;">in</span> (<span class="va" style="color: #111111;">False</span>, <span class="va" style="color: #111111;">None</span>):</span>
<span id="cb4-11">            groups[words[<span class="kw" style="color: #003B4F;">not</span> truth]].add(state)</span>
<span id="cb4-12">    <span class="cf" style="color: #003B4F;">return</span> groups</span>
<span id="cb4-13"></span>
<span id="cb4-14">ask(<span class="st" style="color: #20794D;">'A'</span>, <span class="va" style="color: #111111;">None</span>, STATES)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>{'da': {State(names='ABC', yes='da'),
  State(names='ACB', yes='da'),
  State(names='BAC', yes='ja'),
  State(names='BCA', yes='da'),
  State(names='BCA', yes='ja'),
  State(names='CAB', yes='ja'),
  State(names='CBA', yes='da'),
  State(names='CBA', yes='ja')},
 'ja': {State(names='ABC', yes='ja'),
  State(names='ACB', yes='ja'),
  State(names='BAC', yes='da'),
  State(names='BCA', yes='da'),
  State(names='BCA', yes='ja'),
  State(names='CAB', yes='da'),
  State(names='CBA', yes='da'),
  State(names='CBA', yes='ja')}}</code></pre>
</div>
</div>
<p>To determine if a question is making progress, we need to look at the set of names returned for each answer. A valid solution would need to output sets of at most size <img src="https://latex.codecogs.com/png.latex?2%5E2%20=%204"> on the first question in order to proceed.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="cf" style="color: #003B4F;">for</span> <span class="bu" style="color: null;">id</span> <span class="kw" style="color: #003B4F;">in</span> IDS:</span>
<span id="cb6-2">    groups <span class="op" style="color: #5E5E5E;">=</span> ask(<span class="st" style="color: #20794D;">'A'</span>, <span class="bu" style="color: null;">id</span>, STATES)</span>
<span id="cb6-3">    identities <span class="op" style="color: #5E5E5E;">=</span> [{names <span class="cf" style="color: #003B4F;">for</span> names, _ <span class="kw" style="color: #003B4F;">in</span> group} <span class="cf" style="color: #003B4F;">for</span> group <span class="kw" style="color: #003B4F;">in</span> groups.values()]</span>
<span id="cb6-4">    <span class="bu" style="color: null;">print</span>(<span class="bu" style="color: null;">id</span>, <span class="op" style="color: #5E5E5E;">*</span>identities)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>False {'BAC', 'CBA', 'CAB', 'ABC', 'ACB', 'BCA'} {'CAB', 'CBA', 'BAC', 'ABC', 'ACB', 'BCA'}
True {'CAB', 'CBA', 'BAC', 'ABC', 'ACB', 'BCA'} {'BAC', 'CBA', 'CAB', 'ABC', 'ACB', 'BCA'}
None {'BAC', 'CBA', 'CAB', 'ABC', 'ACB', 'BCA'} {'CAB', 'CBA', 'BAC', 'ABC', 'ACB', 'BCA'}</code></pre>
</div>
</div>
<p>So that question made no progress. Unsurprising given that we don’t know which god is “Random”. Here one could resort to heuristics and increasingly convoluted questions.</p>
<p>Let’s do the opposite: write the most general question possible and automate the search. Any question can be modeled by asking whether any of a given set of states is accurate.</p>
<div class="cell" data-tags="[]" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="kw" style="color: #003B4F;">def</span> ask(name: <span class="bu" style="color: null;">str</span>, include: <span class="bu" style="color: null;">set</span>, exclude: <span class="bu" style="color: null;">set</span>) <span class="op" style="color: #5E5E5E;">-&gt;</span> <span class="bu" style="color: null;">dict</span>:</span>
<span id="cb8-2">    <span class="co" style="color: #5E5E5E;">"""Ask `name`: are we in any of `include` states? and return mapping of answers to possible states."""</span></span>
<span id="cb8-3">    <span class="cf" style="color: #003B4F;">assert</span> include.isdisjoint(exclude)</span>
<span id="cb8-4">    groups <span class="op" style="color: #5E5E5E;">=</span> {word: <span class="bu" style="color: null;">set</span>() <span class="cf" style="color: #003B4F;">for</span> word <span class="kw" style="color: #003B4F;">in</span> WORDS}</span>
<span id="cb8-5">    <span class="cf" style="color: #003B4F;">for</span> state <span class="kw" style="color: #003B4F;">in</span> include <span class="op" style="color: #5E5E5E;">|</span> exclude:</span>
<span id="cb8-6">        identity <span class="op" style="color: #5E5E5E;">=</span> IDS[state.names.index(name)]</span>
<span id="cb8-7">        truth <span class="op" style="color: #5E5E5E;">=</span> state <span class="kw" style="color: #003B4F;">in</span> include</span>
<span id="cb8-8">        words <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">sorted</span>(WORDS, key<span class="op" style="color: #5E5E5E;">=</span>state.yes.<span class="fu" style="color: #4758AB;">__eq__</span>)</span>
<span id="cb8-9">        <span class="cf" style="color: #003B4F;">if</span> identity <span class="kw" style="color: #003B4F;">in</span> (<span class="va" style="color: #111111;">True</span>, <span class="va" style="color: #111111;">None</span>):</span>
<span id="cb8-10">            groups[words[truth]].add(state)</span>
<span id="cb8-11">        <span class="cf" style="color: #003B4F;">if</span> identity <span class="kw" style="color: #003B4F;">in</span> (<span class="va" style="color: #111111;">False</span>, <span class="va" style="color: #111111;">None</span>):</span>
<span id="cb8-12">            groups[words[<span class="kw" style="color: #003B4F;">not</span> truth]].add(state)</span>
<span id="cb8-13">    <span class="cf" style="color: #003B4F;">return</span> groups</span>
<span id="cb8-14"></span>
<span id="cb8-15">include <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(STATES[:<span class="bu" style="color: null;">len</span>(STATES) <span class="op" style="color: #5E5E5E;">//</span> <span class="dv" style="color: #AD0000;">2</span>])</span>
<span id="cb8-16">ask(<span class="st" style="color: #20794D;">'A'</span>, include, <span class="bu" style="color: null;">set</span>(STATES) <span class="op" style="color: #5E5E5E;">-</span> include)        </span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>{'da': {State(names='ABC', yes='ja'),
  State(names='ACB', yes='ja'),
  State(names='BAC', yes='da'),
  State(names='BCA', yes='da'),
  State(names='BCA', yes='ja'),
  State(names='CAB', yes='ja'),
  State(names='CBA', yes='da'),
  State(names='CBA', yes='ja')},
 'ja': {State(names='ABC', yes='da'),
  State(names='ACB', yes='da'),
  State(names='BAC', yes='ja'),
  State(names='BCA', yes='da'),
  State(names='BCA', yes='ja'),
  State(names='CAB', yes='da'),
  State(names='CBA', yes='da'),
  State(names='CBA', yes='ja')}}</code></pre>
</div>
</div>
<p>With that, the <a href="https://en.wikipedia.org/wiki/Power_set">power set</a> of all possible combinations can be searched.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="kw" style="color: #003B4F;">def</span> powerset(states: <span class="bu" style="color: null;">set</span>):</span>
<span id="cb10-2">    <span class="co" style="color: #5E5E5E;">"""Generate all possible subsets."""</span></span>
<span id="cb10-3">    <span class="cf" style="color: #003B4F;">for</span> r <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="bu" style="color: null;">len</span>(states) <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb10-4">        <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="bu" style="color: null;">map</span>(<span class="bu" style="color: null;">set</span>, itertools.combinations(states, r))</span>
<span id="cb10-5"></span>
<span id="cb10-6">count <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb10-7"><span class="cf" style="color: #003B4F;">for</span> states <span class="kw" style="color: #003B4F;">in</span> powerset(STATES):</span>
<span id="cb10-8">    groups <span class="op" style="color: #5E5E5E;">=</span> ask(<span class="st" style="color: #20794D;">'A'</span>, states, <span class="bu" style="color: null;">set</span>(STATES) <span class="op" style="color: #5E5E5E;">-</span> states)</span>
<span id="cb10-9">    identities <span class="op" style="color: #5E5E5E;">=</span> [{names <span class="cf" style="color: #003B4F;">for</span> names, _ <span class="kw" style="color: #003B4F;">in</span> group} <span class="cf" style="color: #003B4F;">for</span> group <span class="kw" style="color: #003B4F;">in</span> groups.values()]</span>
<span id="cb10-10">    count <span class="op" style="color: #5E5E5E;">+=</span> <span class="bu" style="color: null;">max</span>(<span class="bu" style="color: null;">map</span>(<span class="bu" style="color: null;">len</span>, identities)) <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="dv" style="color: #AD0000;">4</span></span>
<span id="cb10-11">count</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>96</code></pre>
</div>
</div>
<p>So there are many potential solutions. Onto automating the search.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="kw" style="color: #003B4F;">def</span> search(states: <span class="bu" style="color: null;">set</span>, count: <span class="bu" style="color: null;">int</span> <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">3</span>):</span>
<span id="cb12-2">    <span class="co" style="color: #5E5E5E;">"""Recursively ask all possible questions until a solution is found."""</span></span>
<span id="cb12-3">    identities <span class="op" style="color: #5E5E5E;">=</span> {names <span class="cf" style="color: #003B4F;">for</span> names, _ <span class="kw" style="color: #003B4F;">in</span> states}</span>
<span id="cb12-4">    <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">len</span>(identities) <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">1</span>:  <span class="co" style="color: #5E5E5E;"># solved</span></span>
<span id="cb12-5">        <span class="cf" style="color: #003B4F;">return</span> identities.pop()</span>
<span id="cb12-6">    <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> count <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">len</span>(identities) <span class="op" style="color: #5E5E5E;">&gt;</span> (<span class="dv" style="color: #AD0000;">2</span> <span class="op" style="color: #5E5E5E;">**</span> count):  <span class="co" style="color: #5E5E5E;"># impossible</span></span>
<span id="cb12-7">        <span class="cf" style="color: #003B4F;">return</span> <span class="va" style="color: #111111;">None</span></span>
<span id="cb12-8">    <span class="cf" style="color: #003B4F;">for</span> name, subset <span class="kw" style="color: #003B4F;">in</span> itertools.product(NAMES, powerset(states)):</span>
<span id="cb12-9">        groups <span class="op" style="color: #5E5E5E;">=</span> ask(name, subset, states <span class="op" style="color: #5E5E5E;">-</span> subset)</span>
<span id="cb12-10">        solutions <span class="op" style="color: #5E5E5E;">=</span> [search(group, count <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">1</span>) <span class="cf" style="color: #003B4F;">for</span> group <span class="kw" style="color: #003B4F;">in</span> groups.values()]</span>
<span id="cb12-11">        <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">all</span>(solutions):</span>
<span id="cb12-12">            <span class="cf" style="color: #003B4F;">return</span> name, subset, solutions</span>
<span id="cb12-13"></span>
<span id="cb12-14">search(<span class="bu" style="color: null;">set</span>(STATES[:<span class="dv" style="color: #AD0000;">2</span>]), <span class="dv" style="color: #AD0000;">0</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>'ABC'</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">search(<span class="bu" style="color: null;">set</span>(STATES[:<span class="dv" style="color: #AD0000;">4</span>]), <span class="dv" style="color: #AD0000;">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>('A',
 {State(names='ABC', yes='da'), State(names='ACB', yes='ja')},
 ['ACB', 'ABC'])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1">search(<span class="bu" style="color: null;">set</span>(STATES[:<span class="dv" style="color: #AD0000;">6</span>]), <span class="dv" style="color: #AD0000;">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>('A',
 {State(names='ABC', yes='da'), State(names='ACB', yes='ja')},
 [('A', {State(names='ACB', yes='da')}, ['BAC', 'ACB']),
  ('A', {State(names='ABC', yes='ja')}, ['ABC', 'BAC'])])</code></pre>
</div>
</div>
<p>So far, so good. The output is binary tree specifying the addressed god and the states asked about at each node.</p>
<p>The sub-problems are solving a sufficient number of cases. It’s no surpise that there should be solutions asking “A” first since it can’t matter who gets the first question. Now for the real solution.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="op" style="color: #5E5E5E;">%</span>time search(<span class="bu" style="color: null;">set</span>(STATES))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 1.29 s, sys: 10.8 ms, total: 1.3 s
Wall time: 1.3 s</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>('A',
 {State(names='ABC', yes='da'),
  State(names='ACB', yes='ja'),
  State(names='BAC', yes='ja'),
  State(names='CAB', yes='da')},
 [('C',
   {State(names='ACB', yes='ja'),
    State(names='BCA', yes='da'),
    State(names='CAB', yes='da'),
    State(names='CBA', yes='ja')},
   [('B',
     {State(names='BCA', yes='ja'), State(names='CBA', yes='ja')},
     ['BCA', 'CBA']),
    ('A',
     {State(names='ACB', yes='da'), State(names='CAB', yes='da')},
     ['CAB', 'ACB'])]),
  ('B',
   {State(names='ABC', yes='da'),
    State(names='BAC', yes='da'),
    State(names='BCA', yes='ja'),
    State(names='CBA', yes='ja')},
   [('B',
     {State(names='ABC', yes='da'), State(names='BCA', yes='da')},
     ['ABC', 'BCA']),
    ('B',
     {State(names='BAC', yes='ja'), State(names='CBA', yes='ja')},
     ['BAC', 'CBA'])])])</code></pre>
</div>
</div>
<p>The puzzle is solved. Can it be simplified? Depends on your point of view.</p>
<p><a href="https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever#The_solution">Canonical solutions</a> introduce <a href="https://en.wikipedia.org/wiki/Logical_biconditional">biconditionals</a> or <a href="https://en.wikipedia.org/wiki/Counterfactual_conditional">conterfactuals</a> in an attempt to collapse the output possibilities. This is ultimately hopeless though, as the solution is a binary search tree regardless. Is asking a question of the form “If I asked you …, would just say ja” actually clearer than asking “Are we in any of these possibilities: …”?</p>
<p>Nonetheless patterns do emerge:</p>
<ul>
<li>The first question revolves around ruling out “Random”.</li>
<li>Subsequent questions address non-“Random” gods.</li>
</ul>
<p>The random behavior adds true complexity to the algorithm, whereas the the boolean encoding adds arbitrary complications.</p>


</section>

 ]]></description>
  <category>puzzles</category>
  <guid>https://coady.github.io/posts/hardest-logic-puzzle-ever.html</guid>
  <pubDate>Fri, 01 Jan 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>GraphQL - ORM</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/graphql-orm.html</link>
  <description><![CDATA[ 




<section id="graphql-is-the-new-orm." class="level1">
<h1>GraphQL is the new ORM.</h1>
<p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> and <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORMs</a> are both infamous for: * over-fetching: fetching more data than is needed per request * under-fetching: fetching less data than is needed, requiring multiple requests * select N+1 problem: under-fetching applied to multiple associated objects</p>
<p><a href="https://en.wikipedia.org/wiki/GraphQL">GraphQL</a> aims to overcome REST’s shortcomings through a flexible query language, and succeeds in doing so on the client side. But on the server side, GraphQL resolvers have effectively recreated the same over- and under- fetching problems that have long plagued ORMs. The fact that ORMs remain popular despite of their inefficiency is a testament to the benefits of having in-memory objects behave consistently. There is no such trade-off for server-side GraphQL, where the only point of the objects is to be immediately serialized.</p>
<p>The so-called <a href="https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching">N+1 problem</a> is generally acknowledged in the GraphQL community, but this article will argue only the symptoms are being addressed with workarounds like <a href="https://github.com/graphql/dataloader">dataloader</a>.</p>
<section id="example" class="level2">
<h2 class="anchored" data-anchor-id="example">Example</h2>
<p>The problems can be seen immediately in GraphQL’s own introductory <a href="https://graphql.org/learn/execution/#root-fields-resolvers">resolver example</a>.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb1-1">Query<span class="op" style="color: #5E5E5E;">:</span> {</span>
<span id="cb1-2">  <span class="fu" style="color: #4758AB;">human</span>(obj<span class="op" style="color: #5E5E5E;">,</span> args<span class="op" style="color: #5E5E5E;">,</span> context<span class="op" style="color: #5E5E5E;">,</span> info) {</span>
<span id="cb1-3">    <span class="cf" style="color: #003B4F;">return</span> context<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">db</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">loadHumanByID</span>(args<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">id</span>)<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">then</span>(</span>
<span id="cb1-4">      userData <span class="kw" style="color: #003B4F;">=&gt;</span> <span class="kw" style="color: #003B4F;">new</span> <span class="fu" style="color: #4758AB;">Human</span>(userData)</span>
<span id="cb1-5">    )</span>
<span id="cb1-6">  }</span>
<span id="cb1-7">}</span>
<span id="cb1-8"></span>
<span id="cb1-9">Human<span class="op" style="color: #5E5E5E;">:</span> {</span>
<span id="cb1-10">  <span class="fu" style="color: #4758AB;">name</span>(obj<span class="op" style="color: #5E5E5E;">,</span> args<span class="op" style="color: #5E5E5E;">,</span> context<span class="op" style="color: #5E5E5E;">,</span> info) {</span>
<span id="cb1-11">    <span class="cf" style="color: #003B4F;">return</span> obj<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">name</span></span>
<span id="cb1-12">  }</span>
<span id="cb1-13">}</span></code></pre></div>
<p>What makes the <code>name</code> resolver trivial? It’s pre-fetched by <code>loadHumanByID</code>, whose only parameter is <code>id</code>, so it’s clearly unaware of whether <code>name</code> has been requested. What if the requested field was a nested object, or a json field, or just a large text blob? Then one would clearly be directed towards using a non-trivial resolver which fetches the field on demand. Of course, but then whatever work is common in the human <code>id</code> lookup is duplicated.</p>
<p>This is by no means specific to SQL or relational databases, but SQL is a convenient lingua franca of databases to demonstrate the inefficiency. The choices are:</p>
<ul>
<li><code>SELECT * FROM human WHERE id = ?</code></li>
<li><code>SELECT field FROM human WHERE id = ?</code> repeated for each “expensive” field</li>
</ul>
<p>Even in the simplest possible example, over-fetching has already occurred, and the only proposed workaround is under-fetching. The single query we want is:</p>
<ul>
<li><code>SELECT f1, f2, ... FROM human WHERE id = ?</code> for requested fields</li>
</ul>
<p>In other words, exactly what happens with ORMs, except even ORMs typically offer an option of requesting a subset of fields. Naturally the problem gets worse with list fields.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb2-1">Human<span class="op" style="color: #5E5E5E;">:</span> {</span>
<span id="cb2-2">  <span class="fu" style="color: #4758AB;">appearsIn</span>(obj) {</span>
<span id="cb2-3">    <span class="cf" style="color: #003B4F;">return</span> obj<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">appearsIn</span> <span class="co" style="color: #5E5E5E;">// returns [ 4, 5, 6 ]</span></span>
<span id="cb2-4">  }</span>
<span id="cb2-5">}</span>
<span id="cb2-6"></span>
<span id="cb2-7">Human<span class="op" style="color: #5E5E5E;">:</span> {</span>
<span id="cb2-8">  <span class="fu" style="color: #4758AB;">starships</span>(obj<span class="op" style="color: #5E5E5E;">,</span> args<span class="op" style="color: #5E5E5E;">,</span> context<span class="op" style="color: #5E5E5E;">,</span> info) {</span>
<span id="cb2-9">    <span class="cf" style="color: #003B4F;">return</span> obj<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">starshipIDs</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">map</span>(</span>
<span id="cb2-10">      id <span class="kw" style="color: #003B4F;">=&gt;</span> context<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #657422;">db</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">loadStarshipByID</span>(id)<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">then</span>(</span>
<span id="cb2-11">        shipData <span class="kw" style="color: #003B4F;">=&gt;</span> <span class="kw" style="color: #003B4F;">new</span> <span class="fu" style="color: #4758AB;">Starship</span>(shipData)</span>
<span id="cb2-12">      )</span>
<span id="cb2-13">    )</span>
<span id="cb2-14">  }</span>
<span id="cb2-15">}</span></code></pre></div>
<p>Now there are two sets of associate keys (<code>.appearsIn</code> and <code>.starshipIDs</code>) that have been over-fetched. Nonetheless <code>starships</code> is under-fetched as well. The <code>starships</code> resolver is neither the most efficient nor the simplest way of resolving this field:</p>
<ul>
<li>fetch all the data by human <code>id</code> in the <code>starships</code> resolver</li>
<li>fetch all the data in bulk by <code>starshipIDs</code></li>
<li>push the resolution down to the <code>Starship</code> layer if forced to fetch one at a time</li>
</ul>
<p>The example implementation seems to be going out of its way to showcase JavaScript promises. And the assumptions being made about the underlying data store are unusual:</p>
<ol type="1">
<li>The data is relational in nature.</li>
<li>Associative keys have neglible cost to pre-fetch.</li>
<li>But joins are not available.</li>
<li>And neither are <code>primary key in</code> queries.</li>
</ol>
</section>
<section id="workaround" class="level2">
<h2 class="anchored" data-anchor-id="workaround">Workaround</h2>
<p>From GraphQL’s <a href="https://graphql.org/learn/best-practices/#server-side-batching-caching">best practices</a></p>
<blockquote class="blockquote">
<p>GraphQL is designed in a way that allows you to write clean code on the server, where every field on every type has a focused single-purpose function for resolving that value. However without additional consideration, a naive GraphQL service could be very “chatty” or repeatedly load data from your databases.</p>
</blockquote>
<blockquote class="blockquote">
<p>This is commonly solved by a batching technique, where multiple requests for data from a backend are collected over a short period of time and then dispatched in a single request to an underlying database or microservice by using a tool like Facebook’s DataLoader.</p>
</blockquote>
<p>That’s an understatement. It’s not clear how “naive” differs from best practice.</p>
<p>Clearly there is value in transforming multiple <code>primary key =</code> queries into a single <code>primary key in</code> query. As in the <code>starships</code> example however, that can be done more simply in the parent resolver. There is more value in not needing a <code>primary key in</code> query at all. Furthermore adding caching to a dataloader avoids the central issue.</p>
<p>Again reminiscent of ORMs, any data layer can add caching. The point is efficiently resolving a query requires context, which strict adherence to single-purpose resolvers explictly disregards.</p>
</section>
<section id="aggregation" class="level2">
<h2 class="anchored" data-anchor-id="aggregation">Aggregation</h2>
<p>The inefficencies becomes even more glaring when moving beyond associative keys. Nearly any aggregation requires knowing what summaries are requested. Such as if the <code>appearsIn</code> field optionally included counts or times. Using SQL as an example again, the query would resemble one of:</p>
<ul>
<li><code>SELECT distinct field FROM ...</code></li>
<li><code>SELECT field, count(*) FROM ... GROUP BY field</code></li>
</ul>
<p>The conditional logic <code>if "count" in requested_fields</code> must exist in some form in the code, because the alternatives are over-fetching or under-fetching. Both of which are far more inefficient in this scenario than in the “select N+1” problem. A dataloader-esque approach is not going to be applicable to “group by” operations.</p>
</section>
<section id="computation" class="level2">
<h2 class="anchored" data-anchor-id="computation">Computation</h2>
<p>One last generalized example: computed fields. What are typically query flags in REST (and <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>) APIs, become field selections in GraphQL.</p>
<p>For example, computing scores in a search engine interface. Instead of a <code>scores: Boolean! = false</code> input option, the more obvious approach would be to skip score calculation when the <code>score</code> field isn’t requested.</p>
<p>As with aggregation, the same pattern recurs. It’s unacceptable to over-fetch, i.e., compute the scores when not needed. It’s worse still to under-fetch, i.e., run some sort of lean search that will find matches and then go back and compute scores later.</p>
</section>
<section id="solution" class="level2">
<h2 class="anchored" data-anchor-id="solution">Solution</h2>
<p>The inescapable conclusion is that in some cases parent resolvers need to know which of their children are being requested. There’s no need to throw away GraphQL’s server-side resolver hierarchy. No one is advocating a thousand line root resolver named <code>RunIt</code> that processes the entire query.</p>
<p>All that’s needed is a conceptual shift which encourages introspecting the <code>GraphQLResolveInfo</code> object. The requested fields are right there waiting to be useful, but good luck finding documentation and examples to that effect. In every non-trivial GraphQL project, this author has used a utility like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;">def</span> selections(node):</span>
<span id="cb3-2">    <span class="co" style="color: #5E5E5E;">"""Return tree of field name selections."""</span></span>
<span id="cb3-3">    nodes <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">getattr</span>(node.selection_set, <span class="st" style="color: #20794D;">'selections'</span>, [])</span>
<span id="cb3-4">    <span class="cf" style="color: #003B4F;">return</span> {node.name.value: selections(node) <span class="cf" style="color: #003B4F;">for</span> node <span class="kw" style="color: #003B4F;">in</span> nodes}</span></code></pre></div>
</div>
<p>Those fields would be checked or passed to a data layer as needed. For example, in <a href="https://www.djangoproject.com">Django’s</a> ORM, it could be as simple as appending a query set with <code>.values(*selections(*info.nodes))</code>.</p>
<p>Well, almost. The next issue is that typical GraphQL model validators raise an error if required fields are missing. Thanks validator; the field is missing because the client didn’t request it.</p>
<p>This is actually a different age-old problem: equivocating “optional” and “nullable”. GraphQL requires populating all requested fields, and specifiying whether they may be null. Server-side implementations understandably, but still incorrectly, interpret that by making nullables optional and non-nullables required at the model layer. So typically it’s necessary to pad resolved objects with empty (but not null) data.</p>
<p>Although a minor problem, it reveals the bias related to single-purpose resolvers. The point of GraphQL is to efficiently return only the requested fields, yet standard practice in GraphQL models is to require populating fields that haven’t been requested.</p>
<p>Over- and under- fetching can be addressed directly in resolvers, with the data layer’s own interface, instead of hidden behind another abstraction layer.</p>


</section>
</section>

 ]]></description>
  <category>style</category>
  <guid>https://coady.github.io/posts/graphql-orm.html</guid>
  <pubDate>Mon, 06 Jul 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Closing files</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/closing-files.html</link>
  <description><![CDATA[ 




<section id="contrarian-view-on-closing-files." class="level1">
<h1>Contrarian view on closing files.</h1>
<p>It has become conventional wisdom to always explicitly close file-like objects, via context managers. The <a href="https://google.github.io/styleguide/pyguide.html#311-files-and-sockets">google style guide</a> is representative:</p>
<blockquote class="blockquote">
<p>Explicitly close files and sockets when done with them. Leaving files, sockets or other file-like objects open unnecessarily has many downsides, including:</p>
</blockquote>
<blockquote class="blockquote">
<p>They may consume limited system resources, such as file descriptors. * Code that deals with many such objects may exhaust those resources unnecessarily if they’re not returned to the system promptly after use. * Holding files open may prevent other actions being performed on them, such as moves or deletion. * Files and sockets that are shared throughout a program may inadvertantly be read from or written to after logically being closed. If they are actually closed, attempts to read or write from them will throw exceptions, making the problem known sooner.</p>
</blockquote>
<blockquote class="blockquote">
<p>Furthermore, while files and sockets are automatically closed when the file object is destructed, tying the life-time of the file object to the state of the file is poor practice, for several reasons: * There are no guarantees as to when the runtime will actually run the file’s destructor. Different Python implementations use different memory management techniques, such as delayed Garbage Collection, which may increase the object’s lifetime arbitrarily and indefinitely. * Unexpected references to the file may keep it around longer than intended (e.g.&nbsp;in tracebacks of exceptions, inside globals, etc).</p>
</blockquote>
<blockquote class="blockquote">
<p>The preferred way to manage files is using the “with” statement:</p>
</blockquote>
<pre><code>with open("hello.txt") as hello_file:
    for line in hello_file:
        print line</code></pre>
<section id="in-theory" class="level2">
<h2 class="anchored" data-anchor-id="in-theory">In theory</h2>
<p>Good points, and why limit this advice to file descriptors? Any resource may be limited or require exclusivity; that’s why they’re called resources. Similarly one should always explicitly call <code>dict.clear</code> when finished with a <code>dict</code>. After all, “there are no guarantees as to when the runtime will actually run the &lt;object’s&gt; destructor. And”code that deals with many such objects may exhaust those resources unnecessarily”, such as memory, or whatever else is in the <code>dict</code>.</p>
<p>But in all seriousness, this advice is applying a notably higher standard of premature optimization to file descriptors than to any other kind of resource. There are plenty of Python projects that are guaranteed to run on CPython for a variety of reasons, where destructors are immediately called. And there are plenty of Python projects where file descriptor usage is just a non-issue. It’s now depressingly commonplace to see this in <code>setup.py</code> files:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="cf" style="color: #003B4F;">with</span> <span class="bu" style="color: null;">open</span>(<span class="st" style="color: #20794D;">"README.md"</span>) <span class="im" style="color: #00769E;">as</span> readme:</span>
<span id="cb2-2">    long_description <span class="op" style="color: #5E5E5E;">=</span> readme.read()</span></code></pre></div>
</div>
<p>Let’s consider a practical example: a <code>load</code> function which is supposed to read and parse data given a file path.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;">import</span> csv</span>
<span id="cb3-2"><span class="im" style="color: #00769E;">import</span> json</span>
<span id="cb3-3"></span>
<span id="cb3-4"><span class="kw" style="color: #003B4F;">def</span> load(filepath):</span>
<span id="cb3-5">    <span class="co" style="color: #5E5E5E;">"""the supposedly bad way"""</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;">return</span> json.load(<span class="bu" style="color: null;">open</span>(filepath))</span>
<span id="cb3-7"></span>
<span id="cb3-8"><span class="kw" style="color: #003B4F;">def</span> load(filepath):</span>
<span id="cb3-9">    <span class="co" style="color: #5E5E5E;">"""the supposedly good way"""</span></span>
<span id="cb3-10">    <span class="cf" style="color: #003B4F;">with</span> <span class="bu" style="color: null;">open</span>(filepath) <span class="im" style="color: #00769E;">as</span> <span class="bu" style="color: null;">file</span>:</span>
<span id="cb3-11">        <span class="cf" style="color: #003B4F;">return</span> json.load(<span class="bu" style="color: null;">file</span>)</span>
<span id="cb3-12"></span>
<span id="cb3-13"><span class="kw" style="color: #003B4F;">def</span> load(filepath):</span>
<span id="cb3-14">    <span class="co" style="color: #5E5E5E;">"""with a different file format"""</span></span>
<span id="cb3-15">    <span class="cf" style="color: #003B4F;">with</span> <span class="bu" style="color: null;">open</span>(filepath) <span class="im" style="color: #00769E;">as</span> <span class="bu" style="color: null;">file</span>:</span>
<span id="cb3-16">        <span class="cf" style="color: #003B4F;">return</span> csv.reader(<span class="bu" style="color: null;">file</span>)</span></code></pre></div>
</div>
<p>Which versions work correctly? Are you sure? If it’s not immediately obvious why one of these is broken, that’s the point. In fact, it’s worth trying out before reading on.</p>
<p>…</p>
<p>The <code>csv</code> version returns an iterator over a closed file. It’s a violation of procedural abstraction to know whether the result of <code>load</code> is lazily evaluated or not; it’s just supposed to implement an interface. Moreover, according to this best practice, it’s <em>impossible</em> to write the <code>csv</code> version correctly. As absurd as it sounds, it’s just an abstraction that can’t exist.</p>
<p>Defiantly clever readers are probably already trying to fix it. Maybe like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;">def</span> load(filepath):</span>
<span id="cb4-2">    <span class="cf" style="color: #003B4F;">with</span> <span class="bu" style="color: null;">open</span>(filepath) <span class="im" style="color: #00769E;">as</span> <span class="bu" style="color: null;">file</span>:</span>
<span id="cb4-3">        <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> csv.reader(<span class="bu" style="color: null;">file</span>)</span></code></pre></div>
</div>
<p>No, it will not be fixed. This version only appears to work by <em>not</em> closing the file until the generator is exhausted or collected.</p>
<p>This trivial example has deeper implications. If one accepts this practice, then one must also accept that storing a file handle anywhere, such as on an instance, is also disallowed. Unless of course that object then virally implements it owns context manager, ad infinitum.</p>
<p>Furthermore it demonstrates that often the context is not being managed locally. If a file object is passed another function, then it’s being used outside of the context. Let’s revisit the <code>json</code> version, which works because the file is fully read. Doesn’t a json parser have some expensive parsing to do after it’s read the file? It might even throw an error. And isn’t it desirable, trivial, <a href="https://github.com/python/cpython/blob/master/Lib/json/__init__.py#L274">and likely</a> that the implementation releases interest in the file as soon as possible?</p>
<p>So in reality there are scenarios where the supposedly good way could keep the file open <em>longer</em> than the supposedly bad way. The original inline version does exactly what it’s supposed to do: close the file when all interested parties are done with it. Python uses garbage collection to manage shared resources. Any attempt to pretend otherwise will result in code that is broken, inefficient, or reinventing reference counting.</p>
<p>A true believer now has to accept that <code>json.load</code> is a useless and dangerous wrapper, and that the only correct implementation is:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;">def</span> load(filepath):</span>
<span id="cb5-2">    <span class="cf" style="color: #003B4F;">with</span> <span class="bu" style="color: null;">open</span>(filepath) <span class="im" style="color: #00769E;">as</span> <span class="bu" style="color: null;">file</span>:</span>
<span id="cb5-3">        contents <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">file</span>.read()</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;">return</span> json.loads(contents)</span></code></pre></div>
</div>
<p>This line of reasoning reduces to the absurd: a file should never be passed or stored anywhere. Next an example where the practice has caused real-world damage.</p>
</section>
<section id="in-practice" class="level2">
<h2 class="anchored" data-anchor-id="in-practice">In practice</h2>
<p><a href="https://requests.readthedocs.io/en/master/">Requests</a> is one of the most popular python packages, and <a href="https://docs.python.org/3/library/http.client.html#module-http.client">officially recommended</a>. It includes a <a href="http://requests.readthedocs.org/en/latest/user/advanced/#session-objects">Session</a> object which supports closing via a context manager. The vast majority of real-world code uses the the top-level functions or single-use sessions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1">response <span class="op" style="color: #5E5E5E;">=</span> requests.get(...)</span>
<span id="cb6-2"></span>
<span id="cb6-3"><span class="cf" style="color: #003B4F;">with</span> requests.Session() <span class="im" style="color: #00769E;">as</span> session:</span>
<span id="cb6-4">    response <span class="op" style="color: #5E5E5E;">=</span> session.get(...)</span></code></pre></div>
</div>
<p>Sessions manage the connection pool, so this pattern of usage is establishing a new connection every time. There are popular standard API clients which seriously do this, for every single request to the same endpoint.</p>
<p>Requests’ documentation prominently states that “Keep-alive and HTTP connection pooling are 100% automatic”. So part of the blame may lay with that phrasing, since it’s only “automatic” if sessions are reused. But surely a large part of the blame is the dogma of closing sockets, and therefore sessions, explicitly. The whole point of a connection pool is that it may leave connections open, so users who genuinely need this granularity are working at the wrong abstraction layer. <code>http.client</code> is already builtin for that level of control.</p>
<p>Tellingly, requests’ own top-level functions didn’t always close sessions. There’s a long history to that code, including a <a href="https://github.com/kennethreitz/requests/commit/3155bc99362a8c6ab136b6a3bb999732617cd2e5">version that only closed sessions on success</a>. An older version was <a href="https://github.com/kennethreitz/requests/issues/1882">causing warnings</a>, when run to check for such warnings, and was being blamed for the <em>appearance</em> of <a href="https://github.com/kennethreitz/requests/issues/1685">leaking memory</a>. Those threads are essentially debating whether a resource pool is “leaking” resources.</p>
</section>
<section id="truce" class="level2">
<h2 class="anchored" data-anchor-id="truce">Truce</h2>
<p>Prior to <code>with</code> being introduced in Python 2.5, it was <em>not</em> recommended that inlined reading of a file required a <code>try... finally</code> block. Far from it, in the past idioms like <code>open(...).read()</code> and <code>for line in open(...)</code> were lauded for being succinct and expressive. But if all this orphaned file descriptor paranoia was well-founded, it would have been a problem back then too.</p>
<p>Finally, let’s address readability. It could be argued (though it rarely is) that showing the reader when the file is closed has inherent value. Conveniently, that tends to align with having opened the file for writing anyway, thereby needing an reference to it. In which case, the readability is approximately equal, and potential pitfalls are more realistic. But readability is genuinely lost when the file would have been opened in a inline expression.</p>
<p>The best practice is unjustifiably special-casing file descriptors, and not seeing its own reasoning through to its logical conclusion. This author proposes advocating for <em>anonymous read-only</em> <code>open</code> expressions. Your setup script is not going to run out of file descriptors because you wrote <code>open("README.md").read()</code>.</p>


</section>
</section>

 ]]></description>
  <category>style</category>
  <guid>https://coady.github.io/posts/closing-files.html</guid>
  <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Mutable defaults</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/mutable-defaults.html</link>
  <description><![CDATA[ 




<section id="contrarian-view-on-mutable-default-arguments." class="level1">
<h1>Contrarian view on mutable default arguments.</h1>
<p>The use of <a href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments">mutable defaults</a> is probably the most infamous Python gotcha. Default values are evaluated at definition time, which means mutating them will be persistent across multiple calls. Many articles on this topic even use the same <code>append</code> example.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;">def</span> append_to(element, to<span class="op" style="color: #5E5E5E;">=</span>[]):</span>
<span id="cb1-2">    to.append(element)</span>
<span id="cb1-3">    <span class="cf" style="color: #003B4F;">return</span> to</span>
<span id="cb1-4"></span>
<span id="cb1-5">append_to(<span class="dv" style="color: #AD0000;">0</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>[0]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">append_to(<span class="dv" style="color: #AD0000;">1</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[0, 1]</code></pre>
</div>
</div>
<p>And the solution is invariably to use <code>None</code> instead, and convert as needed.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;">def</span> append_to(element, to<span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">None</span>):</span>
<span id="cb5-2">    <span class="cf" style="color: #003B4F;">if</span> to <span class="kw" style="color: #003B4F;">is</span> <span class="va" style="color: #111111;">None</span>:</span>
<span id="cb5-3">        to <span class="op" style="color: #5E5E5E;">=</span> []</span>
<span id="cb5-4">    to.append(element)</span>
<span id="cb5-5">    <span class="cf" style="color: #003B4F;">return</span> to</span></code></pre></div>
</div>
<p>There is another solution to the problem of mutating a default value: don’t do that. More specifically, the problem isn’t using mutables as defaults; the problem is actually mutating them.</p>
<p>If the input from the caller is being mutated, then the caller doesn’t need it returned because the caller already has a reference. This distinction is explicitly encouraged in Python, e.g., <code>list.sort</code> vs.&nbsp;<code>sorted</code>. But it follows that if the input doesn’t need to be returned, then there’s no point in the input being optional. How would the caller know the difference?</p>
<p>The reason why examples like the fluent <code>append</code> seem so contrived is because they are. No one actually wants a function named <code>append</code> to take one argument. The realistic fix would be:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;">def</span> append_to(element, to):</span>
<span id="cb6-2">    to.append(element)</span>
<span id="cb6-3">    <span class="cf" style="color: #003B4F;">return</span> to</span></code></pre></div>
</div>
<p>Sure, there are rare occassions where a parameter is mutable but optional, such as a recursive algorithm that’s implicitly passing around its own cache. But this author would wager that given any real-world code that’s been bitten by this gotcha there is:</p>
<ul>
<li>a ~90% chance the function would have a related bug if defaults were evaluated at runtime</li>
<li>a ~95% chance the function has a poor interface</li>
</ul>
<p>What harm does this advice do? Well, it’s caused an over-reaction resulting in using <code>None</code> as the only default, even for immutables. It’s so prevalent that it appears many beginners believe using <code>None</code> is the one and only way of making an argument optional.</p>
<p>Besides immutable types, there are also cases where mutation is irrelevant. Consider the following example adapted from a popular project.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;">from</span> typing <span class="im" style="color: #00769E;">import</span> List</span>
<span id="cb7-2"></span>
<span id="cb7-3"><span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>, alist: List <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">None</span>):</span>
<span id="cb7-4">    <span class="va" style="color: #111111;">self</span>.alist <span class="op" style="color: #5E5E5E;">=</span> [] <span class="cf" style="color: #003B4F;">if</span> alist <span class="kw" style="color: #003B4F;">is</span> <span class="va" style="color: #111111;">None</span> <span class="cf" style="color: #003B4F;">else</span> <span class="bu" style="color: null;">list</span>(alist)</span></code></pre></div>
</div>
<p>Notice that the correctness of this code relies on the member list being newly created in either case. What could possibly go wrong with:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>, alist: List <span class="op" style="color: #5E5E5E;">=</span> []):</span>
<span id="cb8-2">    <span class="va" style="color: #111111;">self</span>.alist <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(alist)</span></code></pre></div>
</div>
<p>Or better yet, why not support the more liberal interface.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="im" style="color: #00769E;">from</span> typing <span class="im" style="color: #00769E;">import</span> Iterable</span>
<span id="cb9-2"></span>
<span id="cb9-3"><span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>, alist: Iterable <span class="op" style="color: #5E5E5E;">=</span> ()):</span>
<span id="cb9-4">    <span class="va" style="color: #111111;">self</span>.alist <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(alist)</span></code></pre></div>
</div>
<p>The point is that there are at least 4 solutions to this problem:</p>
<ol type="1">
<li>use mutable defaults, but don’t mutate them</li>
<li>use immutable substitute defaults with a compatible interface</li>
<li>use <code>None</code> for mutables, and matching types for immutables</li>
<li>use <code>None</code> for all defaults</li>
</ol>
<p>Only #1 is even remotely controversial, yet somehow the status quo has landed on #4. Besides being needlessly verbose, it has another pitfall. Python doesn’t natively support detecting where the argument was actually passed; a sentinel default is required for that. The implementation detail is leaking through the interface, indicating to the caller that <code>None</code> is an acceptable argument to pass <em>explicitly</em>. As if the type hint was <code>Optional[List]</code>, even though that’s not the intention. Factor in using <code>**kwargs</code> - which clearly doesn’t want data padded with nulls - and actual code breakage can result.</p>
<p>Presumably the disdain for option #1 is because it might <em>encourage</em> the gotcha. But it’s disingenous to just let that go unsaid. The implementer is responsible for writing correct code, and the caller sees the right interface. The speculation is that beginners will read code which uses mutable defaults but doesn’t mutate them, and follow the former pattern but not the latter.</p>
<p>As a community, let’s at least push towards option #3. Using empty strings and zeros as defaults is all upside.</p>


</section>

 ]]></description>
  <category>style</category>
  <guid>https://coady.github.io/posts/mutable-defaults.html</guid>
  <pubDate>Sun, 28 Jun 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Water pouring</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/water-pouring.html</link>
  <description><![CDATA[ 




<section id="how-to-solve-the-water-pouring-puzzle-programmatically." class="level1">
<h1>How to solve the <a href="https://en.wikipedia.org/wiki/Water_pouring_puzzle#Variant_with_taps_and_sinks">water pouring puzzle</a> programmatically.</h1>
<p>Given two jugs of capcity of 3 and 5 liters, acquire exactly 4 liters in a jug. Assume an unlimited water supply, and that jugs can only be filled or emptied, i.e., no estimations.</p>
<p>First to model the data: a mapping of jug sizes to their current quantity. There are 3 primitive operations:</p>
<ul>
<li>filling a jug to capacity</li>
<li>emptying a jug entirely</li>
<li>pouring from a source jug to a destination jug, until either the source is emptied or the destination is full</li>
</ul>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;">class</span> Jugs(<span class="bu" style="color: null;">dict</span>):</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;">def</span> fill(<span class="va" style="color: #111111;">self</span>, size):</span>
<span id="cb1-3">        <span class="va" style="color: #111111;">self</span>[size] <span class="op" style="color: #5E5E5E;">=</span> size</span>
<span id="cb1-4"></span>
<span id="cb1-5">    <span class="kw" style="color: #003B4F;">def</span> empty(<span class="va" style="color: #111111;">self</span>, size):</span>
<span id="cb1-6">        <span class="va" style="color: #111111;">self</span>[size] <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb1-7">    </span>
<span id="cb1-8">    <span class="kw" style="color: #003B4F;">def</span> pour(<span class="va" style="color: #111111;">self</span>, src, dest):</span>
<span id="cb1-9">        total <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">self</span>[src] <span class="op" style="color: #5E5E5E;">+</span> <span class="va" style="color: #111111;">self</span>[dest]</span>
<span id="cb1-10">        <span class="va" style="color: #111111;">self</span>[src] <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">max</span>(total <span class="op" style="color: #5E5E5E;">-</span> dest, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb1-11">        <span class="va" style="color: #111111;">self</span>[dest] <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">min</span>(total, dest)</span></code></pre></div>
</div>
<p>That’s sufficient to solve the puzzle through sheer brute force: scanning every possible combination breadth-first. Note the below implementations don’t terminate unless a solution is found.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb2-2"><span class="im" style="color: #00769E;">from</span> functools <span class="im" style="color: #00769E;">import</span> partial</span>
<span id="cb2-3"></span>
<span id="cb2-4">sizes <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">5</span></span>
<span id="cb2-5">operations <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(itertools.chain(</span>
<span id="cb2-6">    (partial(Jugs.fill, size<span class="op" style="color: #5E5E5E;">=</span>size) <span class="cf" style="color: #003B4F;">for</span> size <span class="kw" style="color: #003B4F;">in</span> sizes),</span>
<span id="cb2-7">    (partial(Jugs.empty, size<span class="op" style="color: #5E5E5E;">=</span>size) <span class="cf" style="color: #003B4F;">for</span> size <span class="kw" style="color: #003B4F;">in</span> sizes),</span>
<span id="cb2-8">    (partial(Jugs.pour, src<span class="op" style="color: #5E5E5E;">=</span>src, dest<span class="op" style="color: #5E5E5E;">=</span>dest)</span>
<span id="cb2-9">         <span class="cf" style="color: #003B4F;">for</span> src, dest <span class="kw" style="color: #003B4F;">in</span> itertools.permutations(sizes, <span class="dv" style="color: #AD0000;">2</span>)),</span>
<span id="cb2-10">))</span>
<span id="cb2-11"></span>
<span id="cb2-12"><span class="kw" style="color: #003B4F;">def</span> search(target):</span>
<span id="cb2-13">    <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> itertools.count(<span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb2-14">        <span class="cf" style="color: #003B4F;">for</span> ops <span class="kw" style="color: #003B4F;">in</span> itertools.product(operations, repeat<span class="op" style="color: #5E5E5E;">=</span>n):</span>
<span id="cb2-15">            jugs <span class="op" style="color: #5E5E5E;">=</span> Jugs.fromkeys(sizes, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb2-16">            states <span class="op" style="color: #5E5E5E;">=</span> [op(jugs) <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">tuple</span>(jugs.values()) <span class="cf" style="color: #003B4F;">for</span> op <span class="kw" style="color: #003B4F;">in</span> ops]</span>
<span id="cb2-17">            <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">any</span>(target <span class="kw" style="color: #003B4F;">in</span> state <span class="cf" style="color: #003B4F;">for</span> state <span class="kw" style="color: #003B4F;">in</span> states):</span>
<span id="cb2-18">                <span class="cf" style="color: #003B4F;">return</span> states</span>
<span id="cb2-19"></span>
<span id="cb2-20"><span class="op" style="color: #5E5E5E;">%</span>time search(<span class="dv" style="color: #AD0000;">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 138 ms, sys: 2.28 ms, total: 140 ms
Wall time: 144 ms</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[(0, 5), (3, 2), (0, 2), (2, 0), (2, 5), (3, 4)]</code></pre>
</div>
</div>
<p>Now to relentlessly simplify the code. The first observation is that an empty source is useless, as is a full destination. So the <code>fill</code> and <code>empty</code> primitives are actually unneeded, and can be integrated into the <code>pour</code> method.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;">def</span> pour(jugs, src, dest):</span>
<span id="cb5-2">    <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> jugs[src]:</span>
<span id="cb5-3">        jugs[src] <span class="op" style="color: #5E5E5E;">=</span> src</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;">if</span> jugs[dest] <span class="op" style="color: #5E5E5E;">&gt;=</span> dest:</span>
<span id="cb5-5">        jugs[dest] <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb5-6">    total <span class="op" style="color: #5E5E5E;">=</span> jugs[src] <span class="op" style="color: #5E5E5E;">+</span> jugs[dest]</span>
<span id="cb5-7">    jugs[src] <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">max</span>(total <span class="op" style="color: #5E5E5E;">-</span> dest, <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb5-8">    jugs[dest] <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">min</span>(total, dest)</span>
<span id="cb5-9"></span>
<span id="cb5-10">operations <span class="op" style="color: #5E5E5E;">=</span> [partial(pour, src<span class="op" style="color: #5E5E5E;">=</span>src, dest<span class="op" style="color: #5E5E5E;">=</span>dest) </span>
<span id="cb5-11">               <span class="cf" style="color: #003B4F;">for</span> src, dest <span class="kw" style="color: #003B4F;">in</span> itertools.permutations(sizes, <span class="dv" style="color: #AD0000;">2</span>)]</span>
<span id="cb5-12"></span>
<span id="cb5-13"><span class="op" style="color: #5E5E5E;">%</span>time search(<span class="dv" style="color: #AD0000;">4</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 87 µs, sys: 0 ns, total: 87 µs
Wall time: 88.7 µs</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>[(3, 2), (2, 0), (3, 4)]</code></pre>
</div>
</div>
<p>That reduced the search space considerably, but moreover has revealed another simplification: it’s pointless to “undo” a pour. Whether the source was emptied or the destination was filled, whatever reversing the previous pour direction would accomplish could have been done in the first place.</p>
<p>If there were more than 2 jugs, then there could be complex workflows. But with only 2, the first choice in pour directions determines the rest. There are only 2 <em>potential</em> solutions to the puzzle.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="kw" style="color: #003B4F;">def</span> search(target, src, dest):</span>
<span id="cb8-2">    jugs <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">dict</span>.fromkeys((src, dest), <span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb8-3">    <span class="cf" style="color: #003B4F;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb8-4">        pour(jugs, src, dest)</span>
<span id="cb8-5">        <span class="cf" style="color: #003B4F;">yield</span> <span class="bu" style="color: null;">tuple</span>(jugs.values())</span>
<span id="cb8-6">        <span class="cf" style="color: #003B4F;">if</span> target <span class="kw" style="color: #003B4F;">in</span> jugs.values():</span>
<span id="cb8-7">            <span class="cf" style="color: #003B4F;">return</span></span>
<span id="cb8-8"></span>
<span id="cb8-9"><span class="bu" style="color: null;">list</span>(search(<span class="dv" style="color: #AD0000;">4</span>, <span class="dv" style="color: #AD0000;">5</span>, <span class="dv" style="color: #AD0000;">3</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>[(2, 3), (0, 2), (4, 3)]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="bu" style="color: null;">list</span>(search(<span class="dv" style="color: #AD0000;">4</span>, <span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">5</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>[(0, 3), (1, 5), (0, 1), (0, 4)]</code></pre>
</div>
</div>
<p>And both of them are valid solutions. The solution to the puzzle is quite simply: keep pouring. It doesn’t even matter which to start with.</p>
<p>But it can be further simplified. Now it’s clear that the <code>jug</code> data structure is only providing modular arithmetic.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="kw" style="color: #003B4F;">def</span> search(target, src, dest):</span>
<span id="cb12-2">    <span class="cf" style="color: #003B4F;">for</span> n <span class="kw" style="color: #003B4F;">in</span> itertools.count(<span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb12-3">        quot, rem <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">divmod</span>(n <span class="op" style="color: #5E5E5E;">*</span> src <span class="op" style="color: #5E5E5E;">-</span> target, dest)</span>
<span id="cb12-4">        <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> rem:</span>
<span id="cb12-5">            <span class="cf" style="color: #003B4F;">return</span> n, <span class="op" style="color: #5E5E5E;">-</span>quot</span>
<span id="cb12-6"></span>
<span id="cb12-7">search(<span class="dv" style="color: #AD0000;">4</span>, <span class="dv" style="color: #AD0000;">5</span>, <span class="dv" style="color: #AD0000;">3</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>(2, -2)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">search(<span class="dv" style="color: #AD0000;">4</span>, <span class="dv" style="color: #AD0000;">3</span>, <span class="dv" style="color: #AD0000;">5</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>(3, -1)</code></pre>
</div>
</div>
<div class="cell" data-jupyter="{&quot;outputs_hidden&quot;:true}" data-execution_count="8">
<div class="sourceCode cell-code" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><span class="cf" style="color: #003B4F;">assert</span> (<span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span>) <span class="op" style="color: #5E5E5E;">-</span> (<span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span>) <span class="op" style="color: #5E5E5E;">==</span> (<span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">3</span>) <span class="op" style="color: #5E5E5E;">-</span> (<span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">1</span>) <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">4</span></span></code></pre></div>
</div>
<p>The puzzle is looking for integer solutions to <img src="https://latex.codecogs.com/png.latex?%0A%5C%203x%20+%205y%20=%204%0A"> Which is known as a linear <a href="https://en.wikipedia.org/wiki/Diophantine_equation">Diophantine equation</a>, and must have a solution because <img src="https://latex.codecogs.com/png.latex?4"> is a multiple of <img src="https://latex.codecogs.com/png.latex?gcd(3,%205)">.</p>


</section>

 ]]></description>
  <category>puzzles</category>
  <guid>https://coady.github.io/posts/water-pouring.html</guid>
  <pubDate>Sun, 14 Jun 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Coin balance</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/coin-balance.html</link>
  <description><![CDATA[ 




<section id="how-to-solve-the-coin-balance-puzzle-programmatically." class="level1">
<h1>How to solve the coin <a href="https://en.wikipedia.org/wiki/Balance_puzzle#Twelve-coin_problem">balance puzzle</a> programmatically.</h1>
<p>Given a balance and a set of coins, which are all equal in weight except for one, determine which coin is of different weight in as few weighings as possible.</p>
<blockquote class="blockquote">
<p>Twelve-coin problem</p>
</blockquote>
<blockquote class="blockquote">
<p>A more complex version has twelve coins, eleven or twelve of which are identical. If one is different, we don’t know whether it is heavier or lighter than the others. This time the balance may be used three times to determine if there is a unique coin—and if there is, to isolate it and determine its weight relative to the others. (This puzzle and its solution first appeared in an article in 1945.[2]) The problem has a simpler variant with three coins in two weighings, and a more complex variant with 39 coins in four weighings.</p>
</blockquote>
<p>First to model the data:</p>
<ul>
<li>An <code>enum</code> to represent different weights. Following the ternary comparison convention, such as Python 2’s <a href="https://docs.python.org/2.7/library/functions.html?highlight=cmp#cmp">cmp</a>, is convenient.</li>
<li>An object to represent the balance. For testing, it will need to be configurable with the target coin and relative weight.</li>
<li>An object to represent a coin and its state. A <code>class</code> is tempting, but the most useful data structure would keep the coins grouped by their known (or unknown) state anyway. So any hashable unique identifier is sufficient.</li>
</ul>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;">import</span> enum</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;">class</span> Weight(enum.IntEnum):</span>
<span id="cb1-4">    LIGHT <span class="op" style="color: #5E5E5E;">=</span> <span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span></span>
<span id="cb1-5">    EVEN <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb1-6">    HEAVY <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">1</span></span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="kw" style="color: #003B4F;">class</span> Balance:</span>
<span id="cb1-9">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>, coin, weight: Weight):</span>
<span id="cb1-10">        <span class="va" style="color: #111111;">self</span>.coin <span class="op" style="color: #5E5E5E;">=</span> coin</span>
<span id="cb1-11">        <span class="va" style="color: #111111;">self</span>.weight <span class="op" style="color: #5E5E5E;">=</span> weight</span>
<span id="cb1-12"></span>
<span id="cb1-13">    <span class="kw" style="color: #003B4F;">def</span> weigh(<span class="va" style="color: #111111;">self</span>, left: <span class="bu" style="color: null;">set</span>, right: <span class="bu" style="color: null;">set</span>):</span>
<span id="cb1-14">        <span class="co" style="color: #5E5E5E;">"""Return relative Weight of left side to right side."""</span></span>
<span id="cb1-15">        <span class="cf" style="color: #003B4F;">assert</span> <span class="bu" style="color: null;">len</span>(left) <span class="op" style="color: #5E5E5E;">==</span> <span class="bu" style="color: null;">len</span>(right)</span>
<span id="cb1-16">        <span class="cf" style="color: #003B4F;">if</span> <span class="va" style="color: #111111;">self</span>.coin <span class="kw" style="color: #003B4F;">in</span> left:</span>
<span id="cb1-17">            <span class="cf" style="color: #003B4F;">return</span> <span class="va" style="color: #111111;">self</span>.weight</span>
<span id="cb1-18">        <span class="cf" style="color: #003B4F;">if</span> <span class="va" style="color: #111111;">self</span>.coin <span class="kw" style="color: #003B4F;">in</span> right:</span>
<span id="cb1-19">            <span class="cf" style="color: #003B4F;">return</span> Weight(<span class="op" style="color: #5E5E5E;">-</span><span class="va" style="color: #111111;">self</span>.weight)</span>
<span id="cb1-20">        <span class="cf" style="color: #003B4F;">return</span> Weight.EVEN</span>
<span id="cb1-21"></span>
<span id="cb1-22">coins <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'abcdefghijkl'</span></span>
<span id="cb1-23"><span class="cf" style="color: #003B4F;">assert</span> <span class="bu" style="color: null;">len</span>(coins) <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">12</span></span>
<span id="cb1-24">balance <span class="op" style="color: #5E5E5E;">=</span> Balance(<span class="st" style="color: #20794D;">'a'</span>, Weight.LIGHT)</span>
<span id="cb1-25"><span class="cf" style="color: #003B4F;">assert</span> balance.weigh(<span class="st" style="color: #20794D;">'a'</span>, <span class="st" style="color: #20794D;">'b'</span>) <span class="op" style="color: #5E5E5E;">==</span> Weight.LIGHT</span>
<span id="cb1-26"><span class="cf" style="color: #003B4F;">assert</span> balance.weigh(<span class="st" style="color: #20794D;">'b'</span>, <span class="st" style="color: #20794D;">'c'</span>) <span class="op" style="color: #5E5E5E;">==</span> Weight.EVEN</span>
<span id="cb1-27"><span class="cf" style="color: #003B4F;">assert</span> balance.weigh(<span class="st" style="color: #20794D;">'b'</span>, <span class="st" style="color: #20794D;">'a'</span>) <span class="op" style="color: #5E5E5E;">==</span> Weight.HEAVY</span></code></pre></div>
</div>
<p>As is typical with <a href="https://en.wikipedia.org/wiki/Induction_puzzles">induction puzzles</a>, the constants chosen are just large enough to thwart an iterative approach. The 2 weighing variation would be trivial enough for most people to brute force the solution. Whereas 4 weighings would already be such a large decision tree, it would be tedious to even output. The easier approach is solve the puzzle recursively and more generally, for any number of coins and weighings.</p>
<p>So what can be done in a single weighing? Clearly all weighings must have an equal number of coins on each side, else nothing is learned. If it balances, then the different coin is in the unweighed group. If it doesn’t balance, then the different coin is in the weighed group, but additionally it is known whether each coin would be heavy or light based on which side it was on. This is the crucial insight: there’s a variant recursive puzzle embedded inside this puzzle.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Towers of Hanoi</a> is a classic puzzle often used in computer science curricula to teach recursion. This one would suitable as a subsequent more advanced problem.</p>
<p>So what can be done with known coins in a single weighing? If it balances, then as before the different coin is in the unweighed group. But if it doesn’t balance, then which way can be used to further narrow the coins. Consider the heavier side; the different coin must be one of the heavy ones on that side, or one of the light ones on the other side. Therefore the coins can be split into 2 equal sized groups by putting equal numbers of heavy coins on each side, and equal numbers of light coins on each side. One obstacle is that if there aren’t an even number, there will need to be filler coins just to balance. But that won’t be a problem after the first weighing.</p>
<p>Now we can implement a solution to the sub-problem, and build the need for filler coins into the balance implementation. A generator is used so that the output of each weighing can be displayed.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb2-2"></span>
<span id="cb2-3"><span class="kw" style="color: #003B4F;">class</span> Balance:</span>
<span id="cb2-4">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__init__</span>(<span class="va" style="color: #111111;">self</span>, coin, weight: Weight):</span>
<span id="cb2-5">        <span class="va" style="color: #111111;">self</span>.coin <span class="op" style="color: #5E5E5E;">=</span> coin</span>
<span id="cb2-6">        <span class="va" style="color: #111111;">self</span>.weight <span class="op" style="color: #5E5E5E;">=</span> weight</span>
<span id="cb2-7">        <span class="va" style="color: #111111;">self</span>.filler <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>()</span>
<span id="cb2-8"></span>
<span id="cb2-9">    <span class="kw" style="color: #003B4F;">def</span> weigh(<span class="va" style="color: #111111;">self</span>, left: <span class="bu" style="color: null;">set</span>, right: <span class="bu" style="color: null;">set</span>):</span>
<span id="cb2-10">        <span class="co" style="color: #5E5E5E;">"""Return relative Weight of left side to right side."""</span></span>
<span id="cb2-11">        <span class="cf" style="color: #003B4F;">assert</span> <span class="bu" style="color: null;">abs</span>(<span class="bu" style="color: null;">len</span>(left) <span class="op" style="color: #5E5E5E;">-</span> <span class="bu" style="color: null;">len</span>(right)) <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="bu" style="color: null;">len</span>(<span class="va" style="color: #111111;">self</span>.filler)</span>
<span id="cb2-12">        <span class="cf" style="color: #003B4F;">if</span> <span class="va" style="color: #111111;">self</span>.coin <span class="kw" style="color: #003B4F;">in</span> left:</span>
<span id="cb2-13">            <span class="cf" style="color: #003B4F;">return</span> <span class="va" style="color: #111111;">self</span>.weight</span>
<span id="cb2-14">        <span class="cf" style="color: #003B4F;">if</span> <span class="va" style="color: #111111;">self</span>.coin <span class="kw" style="color: #003B4F;">in</span> right:</span>
<span id="cb2-15">            <span class="cf" style="color: #003B4F;">return</span> Weight(<span class="op" style="color: #5E5E5E;">-</span><span class="va" style="color: #111111;">self</span>.weight)</span>
<span id="cb2-16">        <span class="cf" style="color: #003B4F;">return</span> Weight.EVEN</span>
<span id="cb2-17"></span>
<span id="cb2-18">    <span class="kw" style="color: #003B4F;">def</span> find(<span class="va" style="color: #111111;">self</span>, light: <span class="bu" style="color: null;">set</span>, heavy: <span class="bu" style="color: null;">set</span>):</span>
<span id="cb2-19">        <span class="co" style="color: #5E5E5E;">"""Recursively find target coin from sets of potentially light and heavy coins."""</span></span>
<span id="cb2-20">        <span class="cf" style="color: #003B4F;">yield</span> light, heavy</span>
<span id="cb2-21">        union <span class="op" style="color: #5E5E5E;">=</span> light <span class="op" style="color: #5E5E5E;">|</span> heavy</span>
<span id="cb2-22">        <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">len</span>(union) <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="dv" style="color: #AD0000;">1</span>:</span>
<span id="cb2-23">            <span class="cf" style="color: #003B4F;">return</span></span>
<span id="cb2-24">        left, right <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(), <span class="bu" style="color: null;">set</span>()</span>
<span id="cb2-25">        <span class="co" style="color: #5E5E5E;"># split into 3 groups</span></span>
<span id="cb2-26">        <span class="cf" style="color: #003B4F;">for</span> start, third <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">enumerate</span>([left, right]):</span>
<span id="cb2-27">            <span class="cf" style="color: #003B4F;">for</span> group <span class="kw" style="color: #003B4F;">in</span> (light, heavy):</span>
<span id="cb2-28">                third.update(itertools.islice(group, start, <span class="va" style="color: #111111;">None</span>, <span class="dv" style="color: #AD0000;">3</span>))</span>
<span id="cb2-29">        weight <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">self</span>.weigh(left, right)</span>
<span id="cb2-30">        <span class="cf" style="color: #003B4F;">if</span> weight <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb2-31">            light, heavy <span class="op" style="color: #5E5E5E;">=</span> (light <span class="op" style="color: #5E5E5E;">&amp;</span> left), (heavy <span class="op" style="color: #5E5E5E;">&amp;</span> right)</span>
<span id="cb2-32">        <span class="cf" style="color: #003B4F;">elif</span> weight <span class="op" style="color: #5E5E5E;">&gt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb2-33">            light, heavy <span class="op" style="color: #5E5E5E;">=</span> (light <span class="op" style="color: #5E5E5E;">&amp;</span> right), (heavy <span class="op" style="color: #5E5E5E;">&amp;</span> left)</span>
<span id="cb2-34">        <span class="cf" style="color: #003B4F;">else</span>:</span>
<span id="cb2-35">            light, heavy <span class="op" style="color: #5E5E5E;">=</span> (light <span class="op" style="color: #5E5E5E;">-</span> left <span class="op" style="color: #5E5E5E;">-</span> right), (heavy <span class="op" style="color: #5E5E5E;">-</span> left <span class="op" style="color: #5E5E5E;">-</span> right)</span>
<span id="cb2-36">        <span class="va" style="color: #111111;">self</span>.filler.update(union <span class="op" style="color: #5E5E5E;">-</span> light <span class="op" style="color: #5E5E5E;">-</span> heavy)</span>
<span id="cb2-37">        <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.find(light, heavy)</span>
<span id="cb2-38"></span>
<span id="cb2-39">balance <span class="op" style="color: #5E5E5E;">=</span> Balance(<span class="st" style="color: #20794D;">'a'</span>, Weight.LIGHT)</span>
<span id="cb2-40"><span class="cf" style="color: #003B4F;">for</span> light, heavy <span class="kw" style="color: #003B4F;">in</span> balance.find(<span class="bu" style="color: null;">set</span>(<span class="st" style="color: #20794D;">'abc'</span>), <span class="bu" style="color: null;">set</span>(<span class="st" style="color: #20794D;">'def'</span>)):</span>
<span id="cb2-41">    <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">''</span>.join(light), <span class="st" style="color: #20794D;">''</span>.join(heavy))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>cba dfe
a e
a </code></pre>
</div>
</div>
<p>Now with the sub-problem solved, there’s just one thing missing for the main puzzle. In the known case, splitting into 3 equal sized groups is cleary optimal. But in the unknown case, we need to know how many coins to exclude from the weighing. This requires computing how many coins can be handled in the subsolution. Luckily it’s a trivial <a href="https://en.wikipedia.org/wiki/Recurrence_relation">recurrence relation</a>: <code>n</code> weighings can solve 3 times the number of <code>n - 1</code> weighings. <img src="https://latex.codecogs.com/png.latex?%0A%5Cprod_%7B%7D%5En%203%20=%203%5En%0A"></p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;">class</span> Balance(Balance):</span>
<span id="cb4-2">    <span class="kw" style="color: #003B4F;">def</span> solve(<span class="va" style="color: #111111;">self</span>, count: <span class="bu" style="color: null;">int</span>, coins):</span>
<span id="cb4-3">        <span class="co" style="color: #5E5E5E;">"""Recursively find target coin."""</span></span>
<span id="cb4-4">        <span class="cf" style="color: #003B4F;">if</span> count <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb4-5">            <span class="cf" style="color: #003B4F;">return</span></span>
<span id="cb4-6">        weigh <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(itertools.islice(coins, <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">**</span> (count <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">1</span>) <span class="op" style="color: #5E5E5E;">-</span> (<span class="kw" style="color: #003B4F;">not</span> <span class="va" style="color: #111111;">self</span>.filler)))</span>
<span id="cb4-7">        exclude <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(coins) <span class="op" style="color: #5E5E5E;">-</span> weigh</span>
<span id="cb4-8">        left, right <span class="op" style="color: #5E5E5E;">=</span> (<span class="bu" style="color: null;">set</span>(itertools.islice(weigh, start, <span class="va" style="color: #111111;">None</span>, <span class="dv" style="color: #AD0000;">2</span>)) <span class="cf" style="color: #003B4F;">for</span> start <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">2</span>))</span>
<span id="cb4-9">        weight <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">self</span>.weigh(left, right)</span>
<span id="cb4-10">        <span class="va" style="color: #111111;">self</span>.filler.update(exclude <span class="cf" style="color: #003B4F;">if</span> weight <span class="cf" style="color: #003B4F;">else</span> weigh)</span>
<span id="cb4-11">        <span class="cf" style="color: #003B4F;">if</span> weight <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb4-12">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.find(left, right)</span>
<span id="cb4-13">        <span class="cf" style="color: #003B4F;">elif</span> weight <span class="op" style="color: #5E5E5E;">&gt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb4-14">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.find(right, left)</span>
<span id="cb4-15">        <span class="cf" style="color: #003B4F;">else</span>:</span>
<span id="cb4-16">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.solve(count <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">1</span>, exclude)</span>
<span id="cb4-17"></span>
<span id="cb4-18">balance <span class="op" style="color: #5E5E5E;">=</span> Balance(<span class="st" style="color: #20794D;">'a'</span>, Weight.LIGHT)</span>
<span id="cb4-19"><span class="cf" style="color: #003B4F;">for</span> light, heavy <span class="kw" style="color: #003B4F;">in</span> balance.solve(<span class="dv" style="color: #AD0000;">3</span>, coins):</span>
<span id="cb4-20">    <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">''</span>.join(light), <span class="st" style="color: #20794D;">''</span>.join(heavy))</span>
<span id="cb4-21"></span>
<span id="cb4-22"><span class="cf" style="color: #003B4F;">for</span> coin <span class="kw" style="color: #003B4F;">in</span> coins:</span>
<span id="cb4-23">    light, heavy <span class="op" style="color: #5E5E5E;">=</span>  <span class="bu" style="color: null;">list</span>(Balance(coin, Weight.LIGHT).solve(<span class="dv" style="color: #AD0000;">3</span>, coins))[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>]</span>
<span id="cb4-24">    <span class="cf" style="color: #003B4F;">assert</span> light <span class="op" style="color: #5E5E5E;">==</span> {coin} <span class="kw" style="color: #003B4F;">and</span> <span class="kw" style="color: #003B4F;">not</span> heavy</span>
<span id="cb4-25">    light, heavy <span class="op" style="color: #5E5E5E;">=</span>  <span class="bu" style="color: null;">list</span>(Balance(coin, Weight.HEAVY).solve(<span class="dv" style="color: #AD0000;">3</span>, coins))[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>]</span>
<span id="cb4-26">    <span class="cf" style="color: #003B4F;">assert</span> <span class="kw" style="color: #003B4F;">not</span> light <span class="kw" style="color: #003B4F;">and</span> heavy <span class="op" style="color: #5E5E5E;">==</span> {coin}</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>dbah fceg
a e
a </code></pre>
</div>
</div>
<p>The puzzle is solved. There’s one last simplifcation that can be made, but requires a bit more math background. Ideally we wouldn’t need to know the objective number of weighings; the algorithm would just solve any set of coins as efficiently as possible. To do that, the number of coins that can be solved has to be computed. As was done above, but this recurrence relation is more advanced: each weighing can solve <code>3 ^ n</code> more coins. <img src="https://latex.codecogs.com/png.latex?%0A%5Csum_%7Bk=0%7D%5E%7Bn-1%7D%203%5Ek%20=%20(3%5En%20-%201)%20/%202%0A"></p>
<p>With that calculation inverted, the <code>count</code> can be removed from the interface</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="im" style="color: #00769E;">import</span> math</span>
<span id="cb6-2"></span>
<span id="cb6-3"><span class="kw" style="color: #003B4F;">class</span> Balance(Balance):</span>
<span id="cb6-4">    <span class="kw" style="color: #003B4F;">def</span> solve(<span class="va" style="color: #111111;">self</span>, coins):</span>
<span id="cb6-5">        <span class="cf" style="color: #003B4F;">if</span> <span class="kw" style="color: #003B4F;">not</span> coins:</span>
<span id="cb6-6">            <span class="cf" style="color: #003B4F;">return</span></span>
<span id="cb6-7">        count <span class="op" style="color: #5E5E5E;">=</span> math.ceil(math.log(<span class="bu" style="color: null;">len</span>(coins) <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span> <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>, <span class="dv" style="color: #AD0000;">3</span>))</span>
<span id="cb6-8">        weigh <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(itertools.islice(coins, <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">**</span> (count <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">1</span>) <span class="op" style="color: #5E5E5E;">-</span> (<span class="kw" style="color: #003B4F;">not</span> <span class="va" style="color: #111111;">self</span>.filler)))</span>
<span id="cb6-9">        exclude <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(coins) <span class="op" style="color: #5E5E5E;">-</span> weigh</span>
<span id="cb6-10">        left, right <span class="op" style="color: #5E5E5E;">=</span> (<span class="bu" style="color: null;">set</span>(itertools.islice(weigh, start, <span class="va" style="color: #111111;">None</span>, <span class="dv" style="color: #AD0000;">2</span>)) <span class="cf" style="color: #003B4F;">for</span> start <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">2</span>))</span>
<span id="cb6-11">        weight <span class="op" style="color: #5E5E5E;">=</span> <span class="va" style="color: #111111;">self</span>.weigh(left, right)</span>
<span id="cb6-12">        <span class="va" style="color: #111111;">self</span>.filler.update(exclude <span class="cf" style="color: #003B4F;">if</span> weight <span class="cf" style="color: #003B4F;">else</span> weigh)</span>
<span id="cb6-13">        <span class="cf" style="color: #003B4F;">if</span> weight <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb6-14">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.find(left, right)</span>
<span id="cb6-15">        <span class="cf" style="color: #003B4F;">elif</span> weight <span class="op" style="color: #5E5E5E;">&gt;</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb6-16">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.find(right, left)</span>
<span id="cb6-17">        <span class="cf" style="color: #003B4F;">else</span>:</span>
<span id="cb6-18">            <span class="cf" style="color: #003B4F;">yield</span> <span class="cf" style="color: #003B4F;">from</span> <span class="va" style="color: #111111;">self</span>.solve(exclude)</span>
<span id="cb6-19"></span>
<span id="cb6-20">balance <span class="op" style="color: #5E5E5E;">=</span> Balance(<span class="st" style="color: #20794D;">'a'</span>, Weight.LIGHT)</span>
<span id="cb6-21"><span class="cf" style="color: #003B4F;">for</span> light, heavy <span class="kw" style="color: #003B4F;">in</span> balance.solve(coins):</span>
<span id="cb6-22">    <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">''</span>.join(light), <span class="st" style="color: #20794D;">''</span>.join(heavy))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>dbah fceg
a e
a </code></pre>
</div>
</div>
<p>Notice the formula indicates it’s possible to do 13 coins in 3 weighings, and it would be with a filler coin to balance out the 9 that need weighing.</p>


</section>

 ]]></description>
  <category>puzzles</category>
  <guid>https://coady.github.io/posts/coin-balance.html</guid>
  <pubDate>Sun, 07 Jun 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Hat puzzle</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/hat-puzzle.html</link>
  <description><![CDATA[ 




<section id="how-to-solve-the-hat-puzzle-programmatically." class="level1">
<h1>How to solve the <a href="https://en.wikipedia.org/wiki/Hat_puzzle#Ten-Hat_Variant">Hat puzzle</a> programmatically.</h1>
<blockquote class="blockquote">
<p>Ten-Hat Variant</p>
</blockquote>
<blockquote class="blockquote">
<p>In this variant there are 10 prisoners and 10 hats. Each prisoner is assigned a random hat, either red or blue, but the number of each color hat is not known to the prisoners. The prisoners will be lined up single file where each can see the hats in front of him but not behind. Starting with the prisoner in the back of the line and moving forward, they must each, in turn, say only one word which must be “red” or “blue”. If the word matches their hat color they are released, if not, they are killed on the spot. A friendly guard warns them of this test one hour beforehand and tells them that they can formulate a plan where by following the stated rules, 9 of the 10 prisoners will definitely survive, and 1 has a 50/50 chance of survival. What is the plan to achieve the goal?</p>
</blockquote>
<p>This puzzle involves three concepts common to classic logic puzzles:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Theory_of_mind">Theory of mind</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functional_fixedness">Functional fixedness</a></li>
<li><a href="https://en.wikipedia.org/wiki/Induction_puzzles">Induction</a></li>
</ul>
<p>Theory of mind comes into play because each prisoner has differing knowledge, but assumes everyone else will think similarly. Functional fixedness occurs more subtly; each prisoner may state a color only to convey information. But because the information is encoded as a color, it tends to focus thinking on the colors themselves. So to combat that cognitive bias, first create a different enumeration to represent statements. Any binary <code>enum</code> can be mapped back to colors, so why not <code>bool</code>.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">colors <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'red'</span>, <span class="st" style="color: #20794D;">'blue'</span></span>
<span id="cb1-2">colors[<span class="va" style="color: #111111;">False</span>], colors[<span class="va" style="color: #111111;">True</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>('red', 'blue')</code></pre>
</div>
</div>
<p>Which leaves induction: solve the puzzle for the base case (smallest size) first, and then methodically build on that solution. In the case of 1 prisoner, they have no information a priori, and therefore have a 50/50 chance of survival regardless of strategy. This variant of the puzzle already gives the optimal goal, so we know that everyone but the 1st can say their color and be saved, while the 1st can devote their answer to the common cause.</p>
<p>In the case of 2 prisoners, obviously the 1st can say the color of the 2nd. That approach does not scale; it is the path to functional fixedness. Instead, methodically enumerate all possible statements and colors to determine if there is an unambiguous solution.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">table <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(<span class="bu" style="color: null;">zip</span>([<span class="va" style="color: #111111;">False</span>, <span class="va" style="color: #111111;">True</span>], colors))</span>
<span id="cb3-2">table</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[(False, 'red'), (True, 'blue')]</code></pre>
</div>
</div>
<p>The above table is a general solution with no assumptions other than the arbitrary ordering of enums. While it may appear absurdly pedantic, it represents a rule set which is key to building a recursive solution.</p>
<p>In the case of the 3rd prisoner, clearly they can not just repeat the above rule set, because the 3rd would receive no information. But there are only 2 choices, so the only option is to follow the <em>opposite</em> rule set, depending on the 3rd color.</p>
<p>The crucial step is to build off of the existing <code>table</code>.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">table <span class="op" style="color: #5E5E5E;">=</span> [row <span class="op" style="color: #5E5E5E;">+</span> colors[:<span class="dv" style="color: #AD0000;">1</span>] <span class="cf" style="color: #003B4F;">for</span> row <span class="kw" style="color: #003B4F;">in</span> table] <span class="op" style="color: #5E5E5E;">+</span> [(<span class="kw" style="color: #003B4F;">not</span> row[<span class="dv" style="color: #AD0000;">0</span>],) <span class="op" style="color: #5E5E5E;">+</span> row[<span class="dv" style="color: #AD0000;">1</span>:] <span class="op" style="color: #5E5E5E;">+</span> colors[<span class="dv" style="color: #AD0000;">1</span>:] <span class="cf" style="color: #003B4F;">for</span> row <span class="kw" style="color: #003B4F;">in</span> table]</span>
<span id="cb5-2">table</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>[(False, 'red', 'red'),
 (True, 'blue', 'red'),
 (True, 'red', 'blue'),
 (False, 'blue', 'blue')]</code></pre>
</div>
</div>
<p>The solution is valid if each prisoner is able to narrow the possibilities to a unique row based on the colors they hear and see.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;">import</span> collections</span>
<span id="cb7-2"></span>
<span id="cb7-3"><span class="kw" style="color: #003B4F;">def</span> test(table):</span>
<span id="cb7-4">    <span class="co" style="color: #5E5E5E;">"""Assert that the input table is a valid solution."""</span></span>
<span id="cb7-5">    (size,) <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(<span class="bu" style="color: null;">map</span>(<span class="bu" style="color: null;">len</span>, table))</span>
<span id="cb7-6">    <span class="cf" style="color: #003B4F;">for</span> index <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(size):</span>
<span id="cb7-7">        counts <span class="op" style="color: #5E5E5E;">=</span> collections.Counter(row[:index] <span class="op" style="color: #5E5E5E;">+</span> row[index <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>:] <span class="cf" style="color: #003B4F;">for</span> row <span class="kw" style="color: #003B4F;">in</span> table)</span>
<span id="cb7-8">        <span class="cf" style="color: #003B4F;">assert</span> <span class="bu" style="color: null;">set</span>(counts.values()) <span class="op" style="color: #5E5E5E;">==</span> {<span class="dv" style="color: #AD0000;">1</span>}</span>
<span id="cb7-9"></span>
<span id="cb7-10">test(table)</span></code></pre></div>
</div>
<p>The general solution is simply the above logic in recursive form, with a parametrized size.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="kw" style="color: #003B4F;">def</span> solve(count: <span class="bu" style="color: null;">int</span>):</span>
<span id="cb8-2">    <span class="co" style="color: #5E5E5E;">"""Generate a flat table of all spoken possibilities."""</span></span>
<span id="cb8-3">    <span class="cf" style="color: #003B4F;">if</span> count <span class="op" style="color: #5E5E5E;">&lt;=</span> <span class="dv" style="color: #AD0000;">1</span>:</span>
<span id="cb8-4">        <span class="cf" style="color: #003B4F;">yield</span> <span class="va" style="color: #111111;">False</span>,</span>
<span id="cb8-5">        <span class="cf" style="color: #003B4F;">return</span></span>
<span id="cb8-6">    <span class="cf" style="color: #003B4F;">for</span> row <span class="kw" style="color: #003B4F;">in</span> solve(count <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb8-7">        <span class="cf" style="color: #003B4F;">yield</span> row <span class="op" style="color: #5E5E5E;">+</span> colors[:<span class="dv" style="color: #AD0000;">1</span>]</span>
<span id="cb8-8">        <span class="cf" style="color: #003B4F;">yield</span> (<span class="kw" style="color: #003B4F;">not</span> row[<span class="dv" style="color: #AD0000;">0</span>],) <span class="op" style="color: #5E5E5E;">+</span> row[<span class="dv" style="color: #AD0000;">1</span>:] <span class="op" style="color: #5E5E5E;">+</span> colors[<span class="dv" style="color: #AD0000;">1</span>:]</span>
<span id="cb8-9"></span>
<span id="cb8-10"><span class="bu" style="color: null;">list</span>(solve(<span class="dv" style="color: #AD0000;">3</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>[(False, 'red', 'red'),
 (True, 'red', 'blue'),
 (True, 'blue', 'red'),
 (False, 'blue', 'blue')]</code></pre>
</div>
</div>
<p>The complicated puzzle is actually a trivial recurrence relation: <img src="https://latex.codecogs.com/png.latex?%0A2%5En%20=%202%5E%7Bn-1%7D%20*%202%0A"> There are <img src="https://latex.codecogs.com/png.latex?2%5En"> states of the prisoners, and each prisoner has <img src="https://latex.codecogs.com/png.latex?n-1"> bits of data. So an additional bit of data from the first is sufficient to solve the puzzle.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1">table <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">list</span>(solve(<span class="dv" style="color: #AD0000;">10</span>))</span>
<span id="cb10-2">test(table)</span>
<span id="cb10-3"><span class="bu" style="color: null;">len</span>(table)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>512</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1">table[:<span class="dv" style="color: #AD0000;">3</span>]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>[(False, 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red'),
 (True, 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'blue'),
 (True, 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'blue', 'red')]</code></pre>
</div>
</div>
<p>The puzzle is solved, but the output is of exponential size, certainly not the succinct solution which makes the puzzle famous. But instead of relying on a flash of insight, this approach produces not just <em>a</em> solution, but <em>the</em> solution. The only arbitrary decision made was the enumeration. Therefore it must be the case that the solution can be summarized.</p>
<p>First, it would be helpful to group the solution by the 1st statement. Any summary function would have to ensure that there is no collision in the grouped possibilities.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">groups <span class="op" style="color: #5E5E5E;">=</span> collections.defaultdict(<span class="bu" style="color: null;">set</span>)</span>
<span id="cb14-2"><span class="cf" style="color: #003B4F;">for</span> row <span class="kw" style="color: #003B4F;">in</span> table:</span>
<span id="cb14-3">    groups[row[<span class="dv" style="color: #AD0000;">0</span>]].add(row[<span class="dv" style="color: #AD0000;">1</span>:])</span>
<span id="cb14-4">groups <span class="op" style="color: #5E5E5E;">=</span> groups[<span class="va" style="color: #111111;">False</span>], groups[<span class="va" style="color: #111111;">True</span>]</span>
<span id="cb14-5"></span>
<span id="cb14-6"><span class="kw" style="color: #003B4F;">def</span> summarize(func, groups):</span>
<span id="cb14-7">    <span class="co" style="color: #5E5E5E;">"""Apply summary function to groups and assert uniqueness."""</span></span>
<span id="cb14-8">    groups <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">tuple</span>(<span class="bu" style="color: null;">set</span>(<span class="bu" style="color: null;">map</span>(func, group)) <span class="cf" style="color: #003B4F;">for</span> group <span class="kw" style="color: #003B4F;">in</span> groups)</span>
<span id="cb14-9">    <span class="cf" style="color: #003B4F;">assert</span> <span class="bu" style="color: null;">set</span>.isdisjoint(<span class="op" style="color: #5E5E5E;">*</span>groups)</span>
<span id="cb14-10">    <span class="cf" style="color: #003B4F;">return</span> groups</span>
<span id="cb14-11"></span>
<span id="cb14-12"><span class="cf" style="color: #003B4F;">assert</span> summarize(<span class="kw" style="color: #003B4F;">lambda</span> g: g, groups) <span class="op" style="color: #5E5E5E;">==</span> groups</span>
<span id="cb14-13"><span class="bu" style="color: null;">tuple</span>(<span class="bu" style="color: null;">map</span>(<span class="bu" style="color: null;">len</span>, groups))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>(256, 256)</code></pre>
</div>
</div>
<p>Now what summaries to attempt? Well there are few properties of sequences to work with: size and order. They are all the same size, so that won’t help. That leaves ordering, which can be easily tested by sorting.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1">summarize(<span class="kw" style="color: #003B4F;">lambda</span> g: <span class="bu" style="color: null;">tuple</span>(<span class="bu" style="color: null;">sorted</span>(g)), groups)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>({('blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'red'),
  ('blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'red', 'red', 'red'),
  ('blue', 'blue', 'blue', 'blue', 'red', 'red', 'red', 'red', 'red'),
  ('blue', 'blue', 'red', 'red', 'red', 'red', 'red', 'red', 'red'),
  ('red', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red')},
 {('blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue'),
  ('blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'red', 'red'),
  ('blue', 'blue', 'blue', 'blue', 'blue', 'red', 'red', 'red', 'red'),
  ('blue', 'blue', 'blue', 'red', 'red', 'red', 'red', 'red', 'red'),
  ('blue', 'red', 'red', 'red', 'red', 'red', 'red', 'red', 'red')})</code></pre>
</div>
</div>
<p>Success. Now that order does not matter, the appropriate data structure is a multiset (a.k.a. bag). Each prisoner can keep track of only how many of each color they hear and see.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1">summarize(<span class="kw" style="color: #003B4F;">lambda</span> g: <span class="bu" style="color: null;">frozenset</span>(collections.Counter(g).items()), groups)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>({frozenset({('blue', 8), ('red', 1)}),
  frozenset({('blue', 2), ('red', 7)}),
  frozenset({('blue', 6), ('red', 3)}),
  frozenset({('blue', 4), ('red', 5)}),
  frozenset({('red', 9)})},
 {frozenset({('blue', 1), ('red', 8)}),
  frozenset({('blue', 7), ('red', 2)}),
  frozenset({('blue', 5), ('red', 4)}),
  frozenset({('blue', 3), ('red', 6)}),
  frozenset({('blue', 9)})})</code></pre>
</div>
</div>
<p>Since there are only 2 colors which sum to a constant, keeping track of just one is sufficient.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb20" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1">summarize(<span class="kw" style="color: #003B4F;">lambda</span> g: g.count(colors[<span class="dv" style="color: #AD0000;">0</span>]), groups)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>({1, 3, 5, 7, 9}, {0, 2, 4, 6, 8})</code></pre>
</div>
</div>
<p>There’s one last pattern to the numbers, which can be used to achieve <a href="https://en.wiktionary.org/wiki/parity">parity</a> with the canonical solution.</p>


</section>

 ]]></description>
  <category>puzzles</category>
  <guid>https://coady.github.io/posts/hat-puzzle.html</guid>
  <pubDate>Sat, 11 Jan 2020 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Split an Iterable</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/split-an-iterable.html</link>
  <description><![CDATA[ 




<section id="split-an-iterable-into-equal-sized-chunks." class="level1">
<h1>Split an iterable into equal sized chunks.</h1>
<p>A common task and interview question, with many variants. It’s frequently <a href="http://stackoverflow.com/questions/312443/">asked and answered</a> in a way that’s suboptimal and only handles <a href="http://stackoverflow.com/questions/6822725/">one specific case</a>. The goal here is to present definitive, general, and efficient solutions.</p>
<p>The first variant is whether or not the chunks will overlap. Although this could be generalized into a <code>step</code> parameter, it’s nearly always the case that <code>step in (1, size)</code>.</p>
<p>The second variant is whether the tail of the data should be returned, if it’s not of equal size. Clearly when <code>step == 1</code> that’s unlikely to be desirable. However, when <code>step == size</code>, that would seem to be the natural choice. And again when <code>1 &lt; step &lt; size</code>, the desired behavior isn’t clear at all.</p>
<p>The third variant is whether to slice sequences, or support any iterable. Obviously working for any iterable would be ideal, but it’s also likely a user would expect slices given a sequence, particularly in the case of strings.</p>
<p>So this author feels it’s best to split the problem in 2 distinct cases: a sliding <code>window</code> for overlapping sequences, and <code>chunks</code> for discrete sequences. In each case, supporting iterables and using advanced iterator algebra for a minimal and efficient solution.</p>
<section id="window" class="level2">
<h2 class="anchored" data-anchor-id="window">Window</h2>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;">def</span> window(iterable, size<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb1-4">    <span class="co" style="color: #5E5E5E;">"""Generate a sliding window of values."""</span></span>
<span id="cb1-5">    its <span class="op" style="color: #5E5E5E;">=</span> itertools.tee(iterable, size)</span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">zip</span>(<span class="op" style="color: #5E5E5E;">*</span>(itertools.islice(it, index, <span class="va" style="color: #111111;">None</span>) <span class="cf" style="color: #003B4F;">for</span> index, it <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">enumerate</span>(its)))</span>
<span id="cb1-7"></span>
<span id="cb1-8"><span class="bu" style="color: null;">list</span>(window(<span class="st" style="color: #20794D;">'abcde'</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>[('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e')]</code></pre>
</div>
</div>
<p>That’s simple, and close to optimal. There is slight overhead in iterating an <code>islice</code> object, so a minor variant would be to force the step-wise iteration in advance.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;">import</span> collections</span>
<span id="cb3-2"></span>
<span id="cb3-3"><span class="kw" style="color: #003B4F;">def</span> window(iterable, size<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb3-4">    <span class="co" style="color: #5E5E5E;">"""Generate a sliding window of values."""</span></span>
<span id="cb3-5">    its <span class="op" style="color: #5E5E5E;">=</span> itertools.tee(iterable, size)</span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;">for</span> index, it <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">enumerate</span>(its):</span>
<span id="cb3-7">        collections.deque(itertools.islice(it, index), <span class="dv" style="color: #AD0000;">0</span>)  <span class="co" style="color: #5E5E5E;"># exhaust iterator</span></span>
<span id="cb3-8">    <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">zip</span>(<span class="op" style="color: #5E5E5E;">*</span>its)</span>
<span id="cb3-9"></span>
<span id="cb3-10"><span class="bu" style="color: null;">list</span>(window(<span class="st" style="color: #20794D;">'abcde'</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e')]</code></pre>
</div>
</div>
</section>
<section id="chunks" class="level2">
<h2 class="anchored" data-anchor-id="chunks">Chunks</h2>
<p>A lesser-known and under-utilized feature of <code>iter</code> is that in can take a callable (of no arguments) and a sentinel to create an iterator. A perfect use case of the “loop and a half” idiom.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;">def</span> chunks(iterable, size):</span>
<span id="cb5-2">    <span class="co" style="color: #5E5E5E;">"""Generate adjacent chunks of data"""</span></span>
<span id="cb5-3">    it <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">iter</span>(iterable)</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;">return</span> <span class="bu" style="color: null;">iter</span>(<span class="kw" style="color: #003B4F;">lambda</span>: <span class="bu" style="color: null;">tuple</span>(itertools.islice(it, size)), ())</span>
<span id="cb5-5"></span>
<span id="cb5-6"><span class="bu" style="color: null;">list</span>(chunks(<span class="st" style="color: #20794D;">'abcde'</span>, <span class="dv" style="color: #AD0000;">3</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>[('a', 'b', 'c'), ('d', 'e')]</code></pre>
</div>
</div>
<p>This should also be optimal, for reasonable sizes.</p>
</section>
<section id="sequences-with-dispatch" class="level2">
<h2 class="anchored" data-anchor-id="sequences-with-dispatch">Sequences with dispatch</h2>
<p>Rather than explicitly check <code>isinstance</code>, this is a perfect use case for <code>functools.singledispatch</code>.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;">import</span> functools</span>
<span id="cb7-2"><span class="im" style="color: #00769E;">from</span> collections.abc <span class="im" style="color: #00769E;">import</span> Sequence</span>
<span id="cb7-3"></span>
<span id="cb7-4">window <span class="op" style="color: #5E5E5E;">=</span> functools.singledispatch(window)</span>
<span id="cb7-5"></span>
<span id="cb7-6"><span class="at" style="color: #657422;">@window.register</span></span>
<span id="cb7-7"><span class="kw" style="color: #003B4F;">def</span> _(seq: Sequence, size<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">2</span>):</span>
<span id="cb7-8">    <span class="cf" style="color: #003B4F;">for</span> index <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="bu" style="color: null;">len</span>(seq) <span class="op" style="color: #5E5E5E;">-</span> size <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span>):</span>
<span id="cb7-9">        <span class="cf" style="color: #003B4F;">yield</span> seq[index:index <span class="op" style="color: #5E5E5E;">+</span> size]</span>
<span id="cb7-10"></span>
<span id="cb7-11"><span class="bu" style="color: null;">list</span>(window(<span class="st" style="color: #20794D;">'abcde'</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>['ab', 'bc', 'cd', 'de']</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="bu" style="color: null;">list</span>(window(<span class="bu" style="color: null;">iter</span>(<span class="st" style="color: #20794D;">'abcde'</span>)))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>[('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e')]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">chunks <span class="op" style="color: #5E5E5E;">=</span> functools.singledispatch(chunks)</span>
<span id="cb11-2"></span>
<span id="cb11-3"><span class="at" style="color: #657422;">@chunks.register</span></span>
<span id="cb11-4"><span class="kw" style="color: #003B4F;">def</span> _(seq: Sequence, size):</span>
<span id="cb11-5">    <span class="cf" style="color: #003B4F;">for</span> index <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">0</span>, <span class="bu" style="color: null;">len</span>(seq), size):</span>
<span id="cb11-6">        <span class="cf" style="color: #003B4F;">yield</span> seq[index:index <span class="op" style="color: #5E5E5E;">+</span> size]</span>
<span id="cb11-7"></span>
<span id="cb11-8"><span class="bu" style="color: null;">list</span>(chunks(<span class="st" style="color: #20794D;">'abcde'</span>, <span class="dv" style="color: #AD0000;">3</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>['abc', 'de']</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="bu" style="color: null;">list</span>(chunks(<span class="bu" style="color: null;">iter</span>(<span class="st" style="color: #20794D;">'abcde'</span>), <span class="dv" style="color: #AD0000;">3</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>[('a', 'b', 'c'), ('d', 'e')]</code></pre>
</div>
</div>


</section>
</section>

 ]]></description>
  <category>interviews</category>
  <guid>https://coady.github.io/posts/split-an-iterable.html</guid>
  <pubDate>Sat, 28 Dec 2019 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Accumulator</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/accumulator.html</link>
  <description><![CDATA[ 




<section id="a-paul-graham-classic-the-accumulator-function." class="level1">
<h1>A <a href="http://www.paulgraham.com/icad.html">Paul Graham classic</a>, the accumulator function.</h1>
<blockquote class="blockquote">
<p>As an illustration of what I mean about the relative power of programming languages, consider the following problem. We want to write a function that generates accumulators– a function that takes a number n, and returns a function that takes another number i and returns n incremented by i.</p>
</blockquote>
<blockquote class="blockquote">
<p>(That’s incremented by, not plus. An accumulator has to accumulate.)</p>
</blockquote>
<blockquote class="blockquote">
<p>In Common Lisp this would be</p>
</blockquote>
<blockquote class="blockquote">
<p><code>(defun foo (n) (lambda (i) (incf n i)))</code></p>
</blockquote>
<blockquote class="blockquote">
<p>…</p>
</blockquote>
<blockquote class="blockquote">
<p>If you try to translate the Lisp/Perl/Smalltalk/Javascript code into Python you run into some limitations. Because Python doesn’t fully support lexical variables, you have to create a data structure to hold the value of n.&nbsp;And although Python does have a function data type, there is no literal representation for one (unless the body is only a single expression) so you need to create a named function to return. This is what you end up with:</p>
</blockquote>
<blockquote class="blockquote">
<p><code>def foo(n): s = [n] def bar(i): s[0] += i return s[0]  return bar</code></p>
</blockquote>
<blockquote class="blockquote">
<p>Python users might legitimately ask why they can’t just write</p>
</blockquote>
<blockquote class="blockquote">
<p><code>def foo(n): return lambda i: return n += i</code></p>
</blockquote>
<blockquote class="blockquote">
<p>or even</p>
</blockquote>
<blockquote class="blockquote">
<p><code>def foo(n): lambda i: n += i</code></p>
</blockquote>
<blockquote class="blockquote">
<p>and my guess is that they probably will, one day. (But if they don’t want to wait for Python to evolve the rest of the way into Lisp, they could always just…)</p>
</blockquote>
<p>There are <a href="https://en.wikipedia.org/wiki/Function_object#In_Python">other solutions</a>, using function attributes or instances with a <code>__call__</code> method, but none are substantially more elegant. The challenge predates Python 3, which introduced the <code>nonlocal</code> keyword, making this the presumably preferred solution:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;">def</span> foo(n):</span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;">def</span> inc(x):</span>
<span id="cb1-3">        <span class="kw" style="color: #003B4F;">nonlocal</span> n</span>
<span id="cb1-4">        n <span class="op" style="color: #5E5E5E;">+=</span> x</span>
<span id="cb1-5">        <span class="cf" style="color: #003B4F;">return</span> n</span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;">return</span> inc</span>
<span id="cb1-7"></span>
<span id="cb1-8">acc <span class="op" style="color: #5E5E5E;">=</span> foo(<span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb1-9">acc(<span class="dv" style="color: #AD0000;">1</span>)</span>
<span id="cb1-10">acc(<span class="dv" style="color: #AD0000;">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>3</code></pre>
</div>
</div>
<p>There was also yet another alternative as of Python 2.6: using a generator as a coroutine.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;">def</span> foo(n):</span>
<span id="cb3-2">    <span class="cf" style="color: #003B4F;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb3-3">        n <span class="op" style="color: #5E5E5E;">+=</span> <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb3-4"></span>
<span id="cb3-5">acc <span class="op" style="color: #5E5E5E;">=</span> foo(<span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb3-6"><span class="bu" style="color: null;">next</span>(acc)</span>
<span id="cb3-7">acc.send(<span class="dv" style="color: #AD0000;">1</span>)</span>
<span id="cb3-8">acc.send(<span class="dv" style="color: #AD0000;">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>3</code></pre>
</div>
</div>
<p>To satisfy the challenge, that would need to be wrapped with a decorator. The triple <code>partial</code> expression below may seem a little obtuse, but it’s not as bad as it looks. Just unwind it one step at a time.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="im" style="color: #00769E;">from</span> functools <span class="im" style="color: #00769E;">import</span> partial</span>
<span id="cb5-2"></span>
<span id="cb5-3"><span class="at" style="color: #657422;">@partial</span>(partial, partial)</span>
<span id="cb5-4"><span class="kw" style="color: #003B4F;">def</span> coroutine(func, <span class="op" style="color: #5E5E5E;">*</span>args, <span class="op" style="color: #5E5E5E;">**</span>kwargs):</span>
<span id="cb5-5">    gen <span class="op" style="color: #5E5E5E;">=</span> func(<span class="op" style="color: #5E5E5E;">*</span>args, <span class="op" style="color: #5E5E5E;">**</span>kwargs)</span>
<span id="cb5-6">    <span class="bu" style="color: null;">next</span>(gen)</span>
<span id="cb5-7">    <span class="cf" style="color: #003B4F;">return</span> gen.send</span>
<span id="cb5-8"></span>
<span id="cb5-9">coroutine</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>functools.partial(&lt;class 'functools.partial'&gt;, &lt;function coroutine at 0x10bf970e0&gt;)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="at" style="color: #657422;">@coroutine</span></span>
<span id="cb7-2"><span class="kw" style="color: #003B4F;">def</span> foo(n):</span>
<span id="cb7-3">    <span class="cf" style="color: #003B4F;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb7-4">        n <span class="op" style="color: #5E5E5E;">+=</span> <span class="cf" style="color: #003B4F;">yield</span> n</span>
<span id="cb7-5"></span>
<span id="cb7-6">foo</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>functools.partial(&lt;function coroutine at 0x10bf970e0&gt;, &lt;function foo at 0x10bf7eb90&gt;)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1">acc <span class="op" style="color: #5E5E5E;">=</span> foo(<span class="dv" style="color: #AD0000;">0</span>)</span>
<span id="cb9-2">acc</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>&lt;function generator.send&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1">acc(<span class="dv" style="color: #AD0000;">1</span>)</span>
<span id="cb11-2">acc(<span class="dv" style="color: #AD0000;">2</span>)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>3</code></pre>
</div>
</div>
<p>But what’s the most Pythonic solution? This author would argue… don’t. In my experience, I have never really needed <code>global</code> or <code>nonlocal</code> in production code. Typically it’s because the objects in question are <em>mutable</em>, so it’s not necessary to rebind a name in a different scope to a new object.</p>
<p>A typical tell of these kinds of code challenges are that they focus on the interface or implementation exclusively, never both in context. Python numbers are immutable, and have syntactic support for incrementing, so there’s nothing more readable about <code>acc(...)</code> instead of <code>n += ...</code>.</p>
<p>Futhermore, the accumulator object is intended to be used repeatedly, such as in a loop. In a language with such strong iteration support as Python, it’s extremely likely that accumulation will occur in a iterative loop. Indeed, the <em>real</em> accumulator has since been added to the standard library.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="im" style="color: #00769E;">import</span> itertools</span>
<span id="cb13-2"></span>
<span id="cb13-3"><span class="bu" style="color: null;">list</span>(itertools.accumulate(<span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">10</span>)))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]</code></pre>
</div>
</div>


</section>

 ]]></description>
  <category>style</category>
  <guid>https://coady.github.io/posts/accumulator.html</guid>
  <pubDate>Mon, 28 May 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Map and Filter</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/map-and-filter.html</link>
  <description><![CDATA[ 




<section id="contrarian-view-on-map-and-filter." class="level1">
<h1>Contrarian view on <code>map</code> and <code>filter</code>.</h1>
<p>Although <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> is silent on the topic, it’s become recommended in many Python circles to eschew <code>map</code> and <code>filter</code> in favor of generator expressions or list comprehensions. For example, this <a href="http://stackoverflow.com/questions/5426754/google-python-style-guide">Stack Overflow question</a> received and accepted a typical response. Ironically, that question misquoted the <a href="https://google.github.io/styleguide/pyguide.html?showone=Deprecated_Language_Features#Deprecated_Language_Features">google style guide</a>, which this author happens to agree with.</p>
<blockquote class="blockquote">
<p>Use list comprehensions and for loops instead of filter and map <em>when the function argument would have been an inlined lambda anyway</em>. [emphasis added]</p>
</blockquote>
<p>The style guide also shows a non-lambda version as a positive example: &gt; <code>map(math.sqrt, data)</code> # Ok. No inlined lambda expression.</p>
<p>First, a brief history of how the Python community arrived at this state.</p>
<section id="python-1" class="level2">
<h2 class="anchored" data-anchor-id="python-1">Python 1</h2>
<p>Prior to version 2.0, Python had neither list comprehensions nor nested scopes. Therefore simple <code>map</code> and <code>filter</code> operations had to use a <code>for... append</code> loop, or <code>lambda</code>. But the lacked of nested scopes was inherently crippling to the latter approach.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1">x <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb1-2"><span class="bu" style="color: null;">map</span>(<span class="kw" style="color: #003B4F;">lambda</span> y: y <span class="op" style="color: #5E5E5E;">*</span> x, <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">5</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>&lt;map at 0x108e57250&gt;</code></pre>
</div>
</div>
<p>A <code>NameError</code> would have been raised on <code>x</code>, because it’s not defined in the inner scope. One clever work-around was to shadow default arguments.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">x <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb3-2"><span class="bu" style="color: null;">list</span>(<span class="bu" style="color: null;">map</span>(<span class="kw" style="color: #003B4F;">lambda</span> y, x<span class="op" style="color: #5E5E5E;">=</span>x: y <span class="op" style="color: #5E5E5E;">*</span> x, <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">5</span>)))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[0, 2, 4, 6, 8]</code></pre>
</div>
</div>
<p>Unsurprisingly, that was widely viewed as an ugly hack. Many resigned themselves to <code>for... append</code> loops instead.</p>
</section>
<section id="python-2" class="level2">
<h2 class="anchored" data-anchor-id="python-2">Python 2</h2>
<p>Then Python added list comprehensions in 2.0, and that became the <a href="https://en.wikipedia.org/wiki/Zen_of_Python">one obvious way</a> to do it.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">x <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">2</span></span>
<span id="cb5-2">[y <span class="op" style="color: #5E5E5E;">*</span> x <span class="cf" style="color: #003B4F;">for</span> y <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">5</span>)]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>[0, 2, 4, 6, 8]</code></pre>
</div>
</div>
<p>Python acquired nested scopes in the next version, 2.1, but the damage was done. Functional programming in Python in general, and <code>lambda</code> in particular, was widely frowned upon. Even though the lack of nested scopes affected all inner functions used in any context; it was never really about <code>lambda</code> per se.</p>
</section>
<section id="python-3" class="level2">
<h2 class="anchored" data-anchor-id="python-3">Python 3</h2>
<p>It’s sometimes claimed to this day that <code>map</code> and <code>filter</code> only exist for backwards compatibility. But that belies the history of Python 3. <code>map</code>, <code>filter</code>, and <code>reduce</code> were all considered for removal. But only <code>reduce</code> was banished to the <code>functools</code> module. <code>map</code> and <code>filter</code> were not only retained, but updated to return iterators.</p>
<p>So it’s already dubious to claim that using a built-in is unapproved. But the real point is that <code>map</code> and <code>filter</code> remain a higher level abstraction. Sure, with <code>lambda</code> there are the same number of logical components, and it’s just a matter of syntactic sugar. But there is some abstraction value when the functions already have a name.</p>
<p>It’s also commonly pointed out that generator expressions are superior because they can do a <code>map</code> and <code>filter</code> simultaneously, but crucially only if the <code>filter</code> comes first. Consider this task: normalizing an iterable of strings.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1">values <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'sample '</span>, <span class="st" style="color: #20794D;">' '</span></span>
<span id="cb7-2"><span class="bu" style="color: null;">list</span>(<span class="bu" style="color: null;">filter</span>(<span class="va" style="color: #111111;">None</span>, <span class="bu" style="color: null;">map</span>(<span class="bu" style="color: null;">str</span>.strip, values)))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>['sample']</code></pre>
</div>
</div>
<p>Note <code>list</code> is only being used for printing, and should be ignored for the sake of comparisons.</p>
<p>As for the alternative, surely calling <code>strip</code> twice to use a single expression is just plain cheating. So really the only option is:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1">[value <span class="cf" style="color: #003B4F;">for</span> value <span class="kw" style="color: #003B4F;">in</span> (value.strip() <span class="cf" style="color: #003B4F;">for</span> value <span class="kw" style="color: #003B4F;">in</span> values) <span class="cf" style="color: #003B4F;">if</span> value]</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>['sample']</code></pre>
</div>
</div>
<p>Some would consider nested comprehensions already enough to separate with a temporary name. But that’s inadvertently acknowledging how much more verbose it is.</p>
<p>Can it really be claimed that the latter is more readable than the former? It’s just boilerplate, which never seems acknowledged in small examples. But if one only has to double the size of the context to show how verbose comprehensions are, doesn’t that demonstrate the value of <code>map</code> and <code>filter</code>.</p>
</section>
<section id="epilogue" class="level2">
<h2 class="anchored" data-anchor-id="epilogue">Epilogue</h2>
<p>And now a shameless plug of the author’s <a href="https://pypi.org/project/placeholder/">placeholder</a> package for readers who appreciate function-style programming. It provides syntactic sugar for <code>lambda</code>.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="im" style="color: #00769E;">from</span> placeholder <span class="im" style="color: #00769E;">import</span> _</span>
<span id="cb11-2"></span>
<span id="cb11-3"><span class="bu" style="color: null;">list</span>(<span class="bu" style="color: null;">map</span>(_ <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span>, <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">5</span>)))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>[0, 2, 4, 6, 8]</code></pre>
</div>
</div>
<p>But even speaking as the author, <code>map</code> isn’t the best use case. Sort keys are a much better example, since there is no competing syntax.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="bu" style="color: null;">min</span>([<span class="st" style="color: #20794D;">'ab'</span>, <span class="st" style="color: #20794D;">'ba'</span>], key<span class="op" style="color: #5E5E5E;">=</span>_[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>])</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>'ba'</code></pre>
</div>
</div>
<p>Python 3.8’s new <a href="https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions">assignment expressions</a> provide yet another alternative.</p>


</section>
</section>

 ]]></description>
  <category>style</category>
  <guid>https://coady.github.io/posts/map-and-filter.html</guid>
  <pubDate>Sat, 31 Mar 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Fizz Buzz</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/fizz-buzz.html</link>
  <description><![CDATA[ 




<section id="the-infamously-simple-fizzbuzz-problem." class="level1">
<h1>The infamously simple <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming_interviews">FizzBuzz</a> problem.</h1>
<p>Reportedly a high percentage of programmer applicants can’t solve this quickly.</p>
<blockquote class="blockquote">
<p>Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.</p>
</blockquote>
<p>A deep dive on this problem has been done in jest many times, e.g., deliberate over-engineering or <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a>. But in all seriousness, let’s consider what’s the most Pythonic solution. A truncated version of the common solution:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="cf" style="color: #003B4F;">for</span> num <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">1</span>, <span class="dv" style="color: #AD0000;">16</span>):</span>
<span id="cb1-2">    <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span> <span class="kw" style="color: #003B4F;">and</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb1-3">        <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">'FizzBuzz'</span>)</span>
<span id="cb1-4">    <span class="cf" style="color: #003B4F;">elif</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb1-5">        <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">'Fizz'</span>)</span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;">elif</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb1-7">        <span class="bu" style="color: null;">print</span>(<span class="st" style="color: #20794D;">'Buzz'</span>)</span>
<span id="cb1-8">    <span class="cf" style="color: #003B4F;">else</span>:</span>
<span id="cb1-9">        <span class="bu" style="color: null;">print</span>(num)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz</code></pre>
</div>
</div>
<p>Naturally interview questions tend to focus on output, e.g.&nbsp;<code>print</code>, but that’s no reason to skip over basic abstractions or data structures. First, this could be written as a generator, to decouple the <code>print</code> operation and parametrize the numeric range. Alternatively, Python has such strong iterator support that it could also be just a function, ready to be mapped. So let’s reframe the basic solution as:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;">def</span> fizzbuzz(stop):</span>
<span id="cb3-2">    <span class="cf" style="color: #003B4F;">for</span> num <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">1</span>, stop):</span>
<span id="cb3-3">        <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span> <span class="kw" style="color: #003B4F;">and</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb3-4">            <span class="cf" style="color: #003B4F;">yield</span> <span class="st" style="color: #20794D;">'FizzBuzz'</span></span>
<span id="cb3-5">        <span class="cf" style="color: #003B4F;">elif</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb3-6">            <span class="cf" style="color: #003B4F;">yield</span> <span class="st" style="color: #20794D;">'Fizz'</span></span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;">elif</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb3-8">            <span class="cf" style="color: #003B4F;">yield</span> <span class="st" style="color: #20794D;">'Buzz'</span></span>
<span id="cb3-9">        <span class="cf" style="color: #003B4F;">else</span>: </span>
<span id="cb3-10">            <span class="cf" style="color: #003B4F;">yield</span> <span class="bu" style="color: null;">str</span>(num)</span>
<span id="cb3-11"></span>
<span id="cb3-12"><span class="co" style="color: #5E5E5E;">' '</span>.join(fizzbuzz(<span class="dv" style="color: #AD0000;">16</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>'1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz'</code></pre>
</div>
</div>
<p>Even at this size, it’s already violating <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>, or the <a href="https://en.wikipedia.org/wiki/Rule_of_three_%28computer_programming%29">Rule of 3</a>. Clearly the same logic is being repeated with different data.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;">def</span> fizzbuzz(stop):</span>
<span id="cb5-2">    items <span class="op" style="color: #5E5E5E;">=</span> (<span class="dv" style="color: #AD0000;">15</span>, <span class="st" style="color: #20794D;">'FizzBuzz'</span>), (<span class="dv" style="color: #AD0000;">3</span>, <span class="st" style="color: #20794D;">'Fizz'</span>), (<span class="dv" style="color: #AD0000;">5</span>, <span class="st" style="color: #20794D;">'Buzz'</span>)</span>
<span id="cb5-3">    <span class="cf" style="color: #003B4F;">for</span> num <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">1</span>, stop):</span>
<span id="cb5-4">        <span class="cf" style="color: #003B4F;">yield</span> <span class="bu" style="color: null;">next</span>((text <span class="cf" style="color: #003B4F;">for</span> div, text <span class="kw" style="color: #003B4F;">in</span> items <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> div <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>), <span class="bu" style="color: null;">str</span>(num))</span>
<span id="cb5-5"></span>
<span id="cb5-6"><span class="co" style="color: #5E5E5E;">' '</span>.join(fizzbuzz(<span class="dv" style="color: #AD0000;">16</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>'1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz'</code></pre>
</div>
</div>
<p>However, that variation had to introduce the concept of the <a href="https://en.wikipedia.org/wiki/Least_common_multiple">least common multiple</a>. Even in such a trivial problem, there’s a subtlety in how one interprets requirements. The final directive to output “FizzBuzz” can be seen as a mere clarification of the previous directives; certainly not a coincidence. Making this the more obvious solution:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="kw" style="color: #003B4F;">def</span> fizzbuzz(stop):</span>
<span id="cb7-2">    <span class="cf" style="color: #003B4F;">for</span> num <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">1</span>, stop):</span>
<span id="cb7-3">        text <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">''</span></span>
<span id="cb7-4">        <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">3</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb7-5">            text <span class="op" style="color: #5E5E5E;">+=</span> <span class="st" style="color: #20794D;">'Fizz'</span></span>
<span id="cb7-6">        <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> <span class="dv" style="color: #AD0000;">5</span> <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>:</span>
<span id="cb7-7">            text <span class="op" style="color: #5E5E5E;">+=</span> <span class="st" style="color: #20794D;">'Buzz'</span></span>
<span id="cb7-8">        <span class="cf" style="color: #003B4F;">yield</span> text <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">str</span>(num)</span>
<span id="cb7-9"></span>
<span id="cb7-10"><span class="co" style="color: #5E5E5E;">' '</span>.join(fizzbuzz(<span class="dv" style="color: #AD0000;">16</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>'1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz'</code></pre>
</div>
</div>
<p>Arguably that insight is more important, because its duplication grows exponentially, not linearly. There’s a <code>2**N</code> sized case statement to handle <code>N</code> cases, luckily <code>N == 2</code>. Adding just one more directive for the number 7 would make the basic solution unwieldy.</p>
<p>And of course both approaches can be combined.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="kw" style="color: #003B4F;">def</span> fizzbuzz(stop):</span>
<span id="cb9-2">    items <span class="op" style="color: #5E5E5E;">=</span> (<span class="dv" style="color: #AD0000;">3</span>, <span class="st" style="color: #20794D;">'Fizz'</span>), (<span class="dv" style="color: #AD0000;">5</span>, <span class="st" style="color: #20794D;">'Buzz'</span>)</span>
<span id="cb9-3">    <span class="cf" style="color: #003B4F;">for</span> num <span class="kw" style="color: #003B4F;">in</span> <span class="bu" style="color: null;">range</span>(<span class="dv" style="color: #AD0000;">1</span>, stop):</span>
<span id="cb9-4">        <span class="cf" style="color: #003B4F;">yield</span> <span class="st" style="color: #20794D;">''</span>.join(text <span class="cf" style="color: #003B4F;">for</span> div, text <span class="kw" style="color: #003B4F;">in</span> items <span class="cf" style="color: #003B4F;">if</span> num <span class="op" style="color: #5E5E5E;">%</span> div <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">0</span>) <span class="kw" style="color: #003B4F;">or</span> <span class="bu" style="color: null;">str</span>(num)</span>
<span id="cb9-5"></span>
<span id="cb9-6"><span class="co" style="color: #5E5E5E;">' '</span>.join(fizzbuzz(<span class="dv" style="color: #AD0000;">16</span>))</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>'1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz'</code></pre>
</div>
</div>
<p>So is that over-engineered? This author would argue that both deduplication and decoupling logic from data are worth observing. So maybe at this size the final version isn’t necessary, but surely the basic version is not the most Pythonic.</p>


</section>

 ]]></description>
  <category>interviews</category>
  <guid>https://coady.github.io/posts/fizz-buzz.html</guid>
  <pubDate>Sun, 25 Mar 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Cheryl’s Birthday</title>
  <dc:creator>A. Coady</dc:creator>
  <link>https://coady.github.io/posts/cheryls-birthday.html</link>
  <description><![CDATA[ 




<section id="how-to-solve-the-cheryls-birthday-puzzle-programmatically." class="level2">
<h2 class="anchored" data-anchor-id="how-to-solve-the-cheryls-birthday-puzzle-programmatically.">How to solve the <a href="https://en.wikipedia.org/wiki/Cheryl's_Birthday">Cheryl’s Birthday</a> puzzle programmatically.</h2>
<blockquote class="blockquote">
<ol type="1">
<li>Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is. Cheryl gave them a list of 10 possible dates:</li>
</ol>
</blockquote>
<pre><code>    May 15     May 16     May 19
   June 17    June 18
   July 14    July 16
 August 14  August 15  August 17</code></pre>
<ol type="1">
<li>Cheryl then tells Albert and Bernard separately the month and the day of the birthday respectively.</li>
<li>Albert: I don’t know when Cheryl’s birthday is, but I know that Bernard does not know too.</li>
<li>Bernard: At first I don’t know when Cheryl’s birthday is, but I know now.</li>
<li>Albert: Then I also know when Cheryl’s birthday is.</li>
<li>So when is Cheryl’s birthday?</li>
</ol>
<p>As with the <a href="https://github.com/norvig/pytudes/blob/master/ipynb/Cheryl.ipynb">pytudes solution</a>, the goal is to solve the puzzle in code. A different approach is taken here though, for simplicity and extensibility.</p>
<p>The first step is to model the data. A <code>set</code> of <code>Date</code> objects is suitable to represent the current possible dates. Since <code>datetime.date</code> objects require a year, a minimal <code>collections.namedtuple</code> is used instead.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;">from</span> typing <span class="im" style="color: #00769E;">import</span> NamedTuple</span>
<span id="cb2-2"></span>
<span id="cb2-3">DATES <span class="op" style="color: #5E5E5E;">=</span> [<span class="st" style="color: #20794D;">'May 15'</span>,    <span class="st" style="color: #20794D;">'May 16'</span>,    <span class="st" style="color: #20794D;">'May 19'</span>,</span>
<span id="cb2-4">        <span class="st" style="color: #20794D;">'June 17'</span>,   <span class="st" style="color: #20794D;">'June 18'</span>,</span>
<span id="cb2-5">        <span class="st" style="color: #20794D;">'July 14'</span>,   <span class="st" style="color: #20794D;">'July 16'</span>,</span>
<span id="cb2-6">      <span class="st" style="color: #20794D;">'August 14'</span>, <span class="st" style="color: #20794D;">'August 15'</span>, <span class="st" style="color: #20794D;">'August 17'</span>]</span>
<span id="cb2-7"></span>
<span id="cb2-8"><span class="kw" style="color: #003B4F;">class</span> Date(NamedTuple):</span>
<span id="cb2-9">    month: <span class="bu" style="color: null;">str</span></span>
<span id="cb2-10">    day: <span class="bu" style="color: null;">str</span></span>
<span id="cb2-11"></span>
<span id="cb2-12">    <span class="kw" style="color: #003B4F;">def</span> <span class="fu" style="color: #4758AB;">__repr__</span>(<span class="va" style="color: #111111;">self</span>):</span>
<span id="cb2-13">        <span class="cf" style="color: #003B4F;">return</span> <span class="st" style="color: #20794D;">' '</span>.join(<span class="va" style="color: #111111;">self</span>)  <span class="co" style="color: #5E5E5E;"># pretty printing</span></span>
<span id="cb2-14">DATES <span class="op" style="color: #5E5E5E;">=</span> {Date(<span class="op" style="color: #5E5E5E;">*</span>date.split()) <span class="cf" style="color: #003B4F;">for</span> date <span class="kw" style="color: #003B4F;">in</span> DATES}</span>
<span id="cb2-15">DATES</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>{August 14,
 August 15,
 August 17,
 July 14,
 July 16,
 June 17,
 June 18,
 May 15,
 May 16,
 May 19}</code></pre>
</div>
</div>
<p>As is typical of these kinds of puzzles, it assumes all participants have perfect <a href="https://en.wikipedia.org/wiki/Theory_of_mind">Theory of Mind</a>. That is, each participant making a statement is applying their private knowledge to what is publicly known, and assuming everyone else will do the same. With that in mind, the claims made fall into 3 categories:</p>
<ul>
<li>I know …</li>
<li>I don’t know …</li>
<li>They don’t know …</li>
</ul>
<p>The temporal variations “now” and “at first” can be modeled by the current set of dates. Any claim then can be implemented functionally in this form:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;">def</span> claim(field: <span class="bu" style="color: null;">str</span>, dates: <span class="bu" style="color: null;">set</span>) <span class="op" style="color: #5E5E5E;">-&gt;</span> <span class="bu" style="color: null;">set</span>:</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;">"""Return subset of possible dates which would make the claim true.</span></span>
<span id="cb4-3"><span class="co" style="color: #5E5E5E;">    </span></span>
<span id="cb4-4"><span class="co" style="color: #5E5E5E;">    :param field: the field known by the claimant</span></span>
<span id="cb4-5"><span class="co" style="color: #5E5E5E;">    :param dates: the current set of dates publicly known</span></span>
<span id="cb4-6"><span class="co" style="color: #5E5E5E;">    """</span></span></code></pre></div>
</div>
<p>So what does it mean for Albert or Bernard to “know” the correct date? It would mean applying their knowledge of the month or day leaves only one possibility. The “I know …” function therefore groups and filters for uniqueness.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="im" style="color: #00769E;">import</span> collections</span>
<span id="cb5-2"></span>
<span id="cb5-3"><span class="kw" style="color: #003B4F;">def</span> known(field, dates):</span>
<span id="cb5-4">    <span class="co" style="color: #5E5E5E;">"""Return subset of possible dates which would make the claim "I know ..." true."""</span></span>
<span id="cb5-5">    counts <span class="op" style="color: #5E5E5E;">=</span> collections.Counter(<span class="bu" style="color: null;">getattr</span>(date, field) <span class="cf" style="color: #003B4F;">for</span> date <span class="kw" style="color: #003B4F;">in</span> dates)</span>
<span id="cb5-6">    <span class="cf" style="color: #003B4F;">return</span> {date <span class="cf" style="color: #003B4F;">for</span> date <span class="kw" style="color: #003B4F;">in</span> dates <span class="cf" style="color: #003B4F;">if</span> counts[<span class="bu" style="color: null;">getattr</span>(date, field)] <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">1</span>}</span>
<span id="cb5-7"></span>
<span id="cb5-8"><span class="co" style="color: #5E5E5E;"># test what is already publicly known</span></span>
<span id="cb5-9"><span class="cf" style="color: #003B4F;">assert</span> known(<span class="st" style="color: #20794D;">'month'</span>, DATES) <span class="op" style="color: #5E5E5E;">==</span> <span class="bu" style="color: null;">set</span>()</span>
<span id="cb5-10">known(<span class="st" style="color: #20794D;">'day'</span>, DATES)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>{June 18, May 19}</code></pre>
</div>
</div>
<p>To implement “I don’t know …”, <code>known</code> could be parametrized with a different predicate (<code>&gt; 1</code>), or simply use <code>set.difference</code>. “I don’t know …” is so trivial it’s arguably not worth the abstraction.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="kw" style="color: #003B4F;">def</span> unknown(field, dates):</span>
<span id="cb7-2">    <span class="co" style="color: #5E5E5E;">"""Return subset of possible dates which would make the claim "I don't know ..." true."""</span></span>
<span id="cb7-3">    <span class="cf" style="color: #003B4F;">return</span> dates <span class="op" style="color: #5E5E5E;">-</span> known(field, dates)</span></code></pre></div>
</div>
<p>The challenging part is what does it mean for Albert to claim Bernard doesn’t know. All dates that would be knowable to Bernard must clearly be excluded, but Albert would have to exclude them based on his knowledge of the month. So “They don’t know …” is similar to <code>unknown</code>, but the exclusion is based on a different field.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="kw" style="color: #003B4F;">def</span> unknowable(field, dates):</span>
<span id="cb8-2">    <span class="co" style="color: #5E5E5E;">"""Return subset of possible dates which would make the claim "They don't know ..." true."""</span></span>
<span id="cb8-3">    other, <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>(Date._fields) <span class="op" style="color: #5E5E5E;">-</span> {field}</span>
<span id="cb8-4">    exclude <span class="op" style="color: #5E5E5E;">=</span> {<span class="bu" style="color: null;">getattr</span>(date, field) <span class="cf" style="color: #003B4F;">for</span> date <span class="kw" style="color: #003B4F;">in</span> known(other, dates)}</span>
<span id="cb8-5">    <span class="cf" style="color: #003B4F;">return</span> {date <span class="cf" style="color: #003B4F;">for</span> date <span class="kw" style="color: #003B4F;">in</span> dates <span class="cf" style="color: #003B4F;">if</span> <span class="bu" style="color: null;">getattr</span>(date, field) <span class="kw" style="color: #003B4F;">not</span> <span class="kw" style="color: #003B4F;">in</span> exclude}</span></code></pre></div>
</div>
<p>This is sufficient to simply walk through the statements, one at a time.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="co" style="color: #5E5E5E;"># Albert: I don't know when Cheryl's birthday is, but I know that Bernard does not know too.</span></span>
<span id="cb9-2">dates <span class="op" style="color: #5E5E5E;">=</span> unknown(<span class="st" style="color: #20794D;">'month'</span>, DATES)</span>
<span id="cb9-3"><span class="cf" style="color: #003B4F;">assert</span> dates <span class="op" style="color: #5E5E5E;">==</span> DATES  <span class="co" style="color: #5E5E5E;"># already public known</span></span>
<span id="cb9-4">dates <span class="op" style="color: #5E5E5E;">=</span> unknowable(<span class="st" style="color: #20794D;">'month'</span>, dates)</span>
<span id="cb9-5">dates</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>{August 14, August 15, August 17, July 14, July 16}</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="co" style="color: #5E5E5E;"># Bernard: At first I don't know when Cheryl's birthday is, but I know now.</span></span>
<span id="cb11-2"><span class="cf" style="color: #003B4F;">assert</span> dates.isdisjoint(known(<span class="st" style="color: #20794D;">'day'</span>, DATES))  <span class="co" style="color: #5E5E5E;"># already claimed by Albert</span></span>
<span id="cb11-3">dates <span class="op" style="color: #5E5E5E;">=</span> known(<span class="st" style="color: #20794D;">'day'</span>, dates)</span>
<span id="cb11-4">dates</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>{August 15, August 17, July 16}</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="co" style="color: #5E5E5E;"># Albert: Then I also know when Cheryl's birthday is.</span></span>
<span id="cb13-2">known(<span class="st" style="color: #20794D;">'month'</span>, dates)</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>{July 16}</code></pre>
</div>
</div>
<p>Exactly one date is left, indicating success. Now the succinct in-lined version, with no superfluous statements.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1">known(<span class="st" style="color: #20794D;">'month'</span>,                        <span class="co" style="color: #5E5E5E;"># Albert: I know</span></span>
<span id="cb15-2">    known(<span class="st" style="color: #20794D;">'day'</span>,                      <span class="co" style="color: #5E5E5E;"># Bernard: I know</span></span>
<span id="cb15-3">        unknowable(<span class="st" style="color: #20794D;">'month'</span>, DATES)))  <span class="co" style="color: #5E5E5E;"># Albert: Bernard doesn't know</span></span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>{July 16}</code></pre>
</div>
</div>


</section>

 ]]></description>
  <category>puzzles</category>
  <guid>https://coady.github.io/posts/cheryls-birthday.html</guid>
  <pubDate>Tue, 20 Mar 2018 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
